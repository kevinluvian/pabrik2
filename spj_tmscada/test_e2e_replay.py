import unittest
import json
import binascii
import sys
import os
import struct

# Add project root to sys.path
sys.path.append(os.getcwd())

from tmscada_implementation import IndustrialMachineServer

class CapturingMockSocket:
    def __init__(self):
        self.sent_packets = []

    def sendto(self, data, addr):
        self.sent_packets.append(data)

class TestE2EReplay(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        with open('wireshark_mitm_injection_tmscada_clean.json', 'r') as f:
            cls.packets = json.load(f)

    def setUp(self):
        self.server = IndustrialMachineServer("0.0.0.0", 12345)
        self.mock_sock = CapturingMockSocket()
        self.server.sock = self.mock_sock
        # Disable Prometheus start to avoid port conflict or thread leak
        self.server.start = lambda: None 

    def test_replay_log(self):
        # Queue of responses generated by Server but not yet matched against Log
        generated_responses = []
        
        # IP of the Machine (Client)
        MACHINE_IP = "192.168.13.151"
        # IP of the Server (tmScada)
        SERVER_IP = "192.168.13.150"
        
        for i, pkt in enumerate(self.packets):
            layers = pkt['_source']['layers']
            ip_src = layers.get('ip', {}).get('ip.src')
            ip_dst = layers.get('ip', {}).get('ip.dst')
            
            # Extract Payload
            payload_hex = None
            if 'data' in layers and 'data.data' in layers['data']:
                payload_hex = layers['data']['data.data']
            elif 'udp' in layers and 'udp.payload' in layers['udp']:
                payload_hex = layers['udp']['udp.payload']
            
            print('processing packet', i, payload_hex)

            if not payload_hex:
                continue
                
            payload_bytes = binascii.unhexlify(payload_hex.replace(':', ''))
            
            if ip_src == MACHINE_IP and ip_dst == SERVER_IP:
                # REQUEST: Feed to Server
                addr = (MACHINE_IP, 12345) 
                
                # Clear previous captured to track NEW ones
                self.mock_sock.sent_packets = []
                
                # Process
                self.server.process_packet(payload_bytes, addr)
                
                # Collect responses
                generated_responses.extend(self.mock_sock.sent_packets)
                
            elif ip_src == SERVER_IP and ip_dst == MACHINE_IP:
                # RESPONSE: Verify against Generated
                if not generated_responses:
                    continue
                
                actual_resp = generated_responses.pop(0)
                expected_resp = payload_bytes
                
                # Comparison
                if actual_resp == expected_resp:
                    # Exact match
                    continue
                else:
                    # Mismatch - Check if it's an allowed dynamic type
                    if len(actual_resp) > 12 and len(expected_resp) > 12:
                        actual_pid = struct.unpack_from('<I', actual_resp, 12)[0]
                        
                        # Allowed Dynamic PIDs:
                        # 0x1000000: LineStatus Packet 1 (IP, Time)
                        # 0x1000001: LineStatus Packet 2 (CRC issue)
                        if actual_pid in [0x1000000, 0x1000001]:
                             if len(actual_resp) == len(expected_resp):
                                 print(f"Packet {i}: Accepted dynamic mismatch for PID 0x{actual_pid:x}")
                                 continue
                    
                    self.fail(f"Packet {i}: Response Mismatch.\nExpected: {binascii.hexlify(expected_resp)}\nActual:   {binascii.hexlify(actual_resp)}")

        if generated_responses:
             pass

if __name__ == '__main__':
    unittest.main()
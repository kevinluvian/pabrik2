int trigger;void ill_handler;sigjmp_buf ill_jmp;uint OPENSSL_armcap_P;sigset_t all_masked;void __libc_csu_init;void main;void __libc_csu_fini;uint8_t completed.10352;uint32_t __JCR_END__;UA_DataType[163] UA_TYPES;UA_String UA_STRING_NULL;UA_Logger logger;UA_Boolean running;ulong[510] g_fetch_HMI_data_ID;void DAT_001594e8;void DAT_001594f8;uint g_fetch_HMI_data_count;int g_step_flag;void DAT_001594f9;ulong g_index_1;uint16_t DBdata;uint8_t[192] Obj_folder_MOLDPARATOR;void DAT_001090e8;void DAT_0010911c;void DAT_00109138;void DAT_0010914c;long g_send_to_hmi_heartbeat;void pthread_inet;void DAT_00109168;UA_ServerConfig UA_ServerConfig_standard;void DAT_00109184;void DAT_001091a8;void DAT_001091b0;void DAT_001091d0;void DAT_001091e4;long g_send_to_hmi_time;void DAT_001594ec;void DAT_001594f0;void DAT_001594fc;void stopHandler;void readTimeData;long g_send_to_hmi_time_string;UA_NodeId UA_NODEID_NULL;long g_send_to_hmi_offline;pthread_t ntid_hmi;uint[256] _CRC32_Talbe;int u_nDnCounter;long *[64] u_plDnCounter;int u_nUpCounter;long *[64] u_plUpCounter;void DAT_00159540;void DAT_00159544;void DAT_00159548;void DAT_0015954c;void DAT_00159550;void DAT_00159580;void DAT_00159584;void DAT_00159588;void DAT_0015958c;uint16_t DAT_00159500;char[16] g_opc_ua_server_ip;int g_vendor_value;char[6] g_opc_ua_mac;pthread_t m_threadTimer;void Timer_Run;Logger logger;uint32_t stdout;uint32_t stderr;DBDATA_DESC_54_52[1000] DBdata_54_52;char[30] CurrentMoldCfgFileVer;DBDATA_DESC_54_52[1000] DBdata_54_52_B_spec;char[30] CurrentMoldCfgFileDataTime;void DAT_0010fbbc;char[16] outmd;char *black_file_name;UA_DataType[11] UA_TRANSPORT;pcg32_random_t UA_rng;UA_copySignature[26] copyJumpTable;UA_deleteMembersSignature[26] deleteMembersJumpTable;UA_exchangeEncodeBuffer exchangeBufferCallback;UA_Byte *end;UA_Byte *pos;UA_ByteString *encodeBuf;void *exchangeBufferCallbackHandle;UA_encodeBinarySignature[26] encodeBinaryJumpTable;UA_decodeBinarySignature[26] decodeBinaryJumpTable;UA_ByteString UA_BYTESTRING_NULL;UA_calcSizeBinarySignature[26] calcSizeBinaryJumpTable;void UA_SecureChannel_sendChunk;UA_Session adminSession;UA_Session *methodCallSession;void UA_Server_cleanup;void readStatus;void readServiceLevel;void GetMonitoredItems;void readAuditing;void readNamespaces;void readCurrentTime;void Service_UnregisterNodes;void Service_DeleteSubscriptions;void Service_CreateSession;void Service_Write;void Service_Read;void Service_DeleteReferences;void Service_ModifyMonitoredItems;void Service_CreateMonitoredItems;void Service_RegisterNodes;void Service_Browse;void Service_FindServers;void Service_SetMonitoringMode;void Service_ActivateSession;void Service_DeleteNodes;void Service_AddReferences;void Service_Call;void Service_CreateSubscription;void Service_ModifySubscription;void Service_Republish;void Service_BrowseNext;void Service_DeleteMonitoredItems;void Service_CloseSession;void Service_GetEndpoints;void Service_AddNodes;void Service_TranslateBrowsePathsToNodeIds;void Service_SetPublishingMode;UA_Guid UA_GUID_NULL;void UA_Server_processSecureChannelMessage;int[10] g_buffer;hash_t[30] primes;UA_String binEncoding;void CopyAttributeIntoNode;void setObjectInstanceHandle;void addOneWayReference;void deleteOneWayReference;void setValueCallback;void setDataSource;void setOLM;void editMethodCallback;void UA_MoniteredItem_SampleCallback;void UA_Subscription_publishCallback;UA_String binaryEncoding;void UA_Subscription_answerPublishRequestsNoSubscription;void processServiceResponse;void socket_write;void ServerNetworkLayerTCP_closeConnection;void ServerNetworkLayerGetSendBuffer;void ServerNetworkLayerReleaseSendBuffer;void ServerNetworkLayerReleaseRecvBuffer;void FreeConnectionCallback;void ServerNetworkLayerTCP_start;void ServerNetworkLayerTCP_getJobs;void ServerNetworkLayerTCP_stop;void ServerNetworkLayerTCP_deleteMembers;void ClientNetworkLayerReleaseBuffer;void ClientNetworkLayerClose;void socket_recv;void ClientNetworkLayerGetBuffer;char *[6] LogLevelNames;char *[6] LogCategoryNames;UA_StatusCodeDescription[229] statusCodeDescriptions;BOUND_AB bound_ab;BOUND_A bound_a;int u_recvbuff_length;uint32_t DAT_00159c00;uint nCRC;int sockfd;sockaddr_in adr_clnt;ulong testdw_id;WORD g_style_type;WORD g_MAX_Temp;int g_SPEED_Precious;int g_get_SPEED_Precious;int g_get_Position_Precious;int g_Position_Precious;WORD g_machine_type;char g_hmiversion_flag;uint16_t g_u16Version;char[2] g_HMIversion;uint32_t DAT_0011b7c0;int[4] g_HMI_ip_address_new;uint32_t DAT_0011b7a0;char[6] g_MAC_address;int[4] g_HMI_ip_address;char[30] g_HMI_ip_address_52_ip;sockaddr_in adr_inet;int[4] g_HMI_ip_address_old;BYTE[1480] u_bySendData;USER[4] u_aUserTable;uint8_t DAT_0015a778;char[1000] g_modepara_preci;void DAT_0011b850;void DAT_0011b860;void DAT_0011b870;char *molddata_54_52_file_name;ifreq g_700_mac_ifr;uint8_t[264] precision_54_52;char[16] g_inet_server_ip;char[1400] send_buff;char[18] opc_ua_mac_700;pthread_mutex_t mutexlock;COMMMAP[18] u_aHMICommMap;int CurrentMoldData54_52Count;char[6000] moldset;char[3] g_error_flag;int[3] g_error_code;uint8_t[2344] error_buff;char roll_flag;ERROR error;void DAT_001598c0;void DAT_001598c4;void DAT_001598c8;void DAT_001598cc;void DAT_001598d0;void DAT_001598d4;void DAT_001598d8;uint16_t DAT_001598dc;MODIFY modify;ENERGY energy;TEMPER temper;int g_OperateMode_i;short g_wErrorState;int DAT_00159c00;char g_error_end_flag;char g_error_state_flag;OPERSTATE operstate;MONITOR monitor;char[100] decryptMsg;uint16_t g_u16Index;uint8_t g_u8ModeFlag;BYTE[757] g_awNet2TxBuffer;CboxErrorData[256] Error;MLDH moldH;char[6000] moldset_buff;int[8] u_recv_length;uchar[28] m;uchar[32] m;void DAT_00052af0;void DAT_00052b00;void DAT_00052b10;uint64_t DAT_00052b20;void DAT_00052b30;void DAT_00052b40;void DAT_00052b50;void DAT_00052b60;void UNK_00052b70;void UNK_00052b80;void UNK_00052b90;void UNK_00052ba0;void UNK_00052bb0;void UNK_00052bc0;void UNK_00052bd0;uint64_t K256;void DAT_00052b20;RSA_METHOD *default_RSA_meth;ENGINE_TABLE *rsa_table;void engine_unregister_all_RSA;int dummy_nid;BIO_METHOD mem_method;ENGINE *funct_ref;RAND_METHOD *default_RAND_meth;int int_err_library_number;lhash_st_ERR_STRING_DATA *int_error_hash;int int_thread_hash_references;void err_state_LHASH_COMP;void err_state_LHASH_HASH;lhash_st_ERR_STATE *int_thread_hash;void err_string_data_LHASH_HASH;void err_string_data_LHASH_COMP;ERR_FNS err_defaults;ERR_FNS *err_fns;ERR_STRING_DATA[128] SYS_str_reasons;int init;ERR_STRING_DATA[29] ERR_str_libraries;ERR_STRING_DATA[37] ERR_str_reasons;ERR_STRING_DATA[11] ERR_str_functs;char[127][32] strerror_tab;char[256] buf;ERR_STATE fallback;void AES_cbc_encrypt;void AES_decrypt;void bsaes_cbc_encrypt;void bsaes_ctr32_encrypt_blocks;void AES_encrypt;void aes_v8_decrypt;void aes_v8_ctr32_encrypt_blocks;void aes_v8_encrypt;void aes_v8_cbc_encrypt;void bsaes_xts_encrypt;void bsaes_xts_decrypt;EVP_CIPHER aes_128_cbc;EVP_CIPHER aes_128_ecb;EVP_CIPHER aes_128_ofb;EVP_CIPHER aes_128_cfb;EVP_CIPHER aes_128_cfb1;EVP_CIPHER aes_128_cfb8;EVP_CIPHER aes_128_ctr;EVP_CIPHER aes_192_cbc;EVP_CIPHER aes_192_ecb;EVP_CIPHER aes_192_ofb;EVP_CIPHER aes_192_cfb;EVP_CIPHER aes_192_cfb1;EVP_CIPHER aes_192_cfb8;EVP_CIPHER aes_192_ctr;EVP_CIPHER aes_256_cbc;EVP_CIPHER aes_256_ecb;EVP_CIPHER aes_256_ofb;EVP_CIPHER aes_256_cfb;EVP_CIPHER aes_256_cfb1;EVP_CIPHER aes_256_cfb8;EVP_CIPHER aes_256_ctr;EVP_CIPHER aes_128_gcm;EVP_CIPHER aes_192_gcm;EVP_CIPHER aes_256_gcm;EVP_CIPHER aes_128_xts;EVP_CIPHER aes_256_xts;EVP_CIPHER aes_128_ccm;EVP_CIPHER aes_192_ccm;EVP_CIPHER aes_256_ccm;EVP_CIPHER aes_128_wrap;EVP_CIPHER aes_192_wrap;EVP_CIPHER aes_256_wrap;int obj_cleanup_defer;void do_all_cipher_fn;void do_all_md_fn;BIO_METHOD methods_b64;_func_void_void_ptr_int *free_debug_func;_func_void_void_ptr *free_func;void pbe_cmp;stack_st_EVP_PBE_CTL *pbe_algs;void pbe2_cmp_BSEARCH_CMP_FN;EVP_PBE_CTL[21] builtin_pbe;void DAT_0011caf4;void free_evp_pbe_ctl;EVP_CIPHER r4_hmac_md5_cipher;uint8_t DAT_0011caec;ASN1_ITEM X509_SIG_it;void der_cmp;ulong[32] tag2bit;ASN1_ITEM ASN1_INTEGER_it;ASN1_ITEM ASN1_ENUMERATED_it;ASN1_ITEM ASN1_BIT_STRING_it;ASN1_ITEM ASN1_OCTET_STRING_it;ASN1_ITEM ASN1_NULL_it;ASN1_ITEM ASN1_UTF8STRING_it;ASN1_ITEM ASN1_PRINTABLESTRING_it;ASN1_ITEM ASN1_T61STRING_it;ASN1_ITEM ASN1_IA5STRING_it;ASN1_ITEM ASN1_GENERALSTRING_it;ASN1_ITEM ASN1_UTCTIME_it;ASN1_ITEM ASN1_GENERALIZEDTIME_it;ASN1_ITEM ASN1_VISIBLESTRING_it;ASN1_ITEM ASN1_UNIVERSALSTRING_it;ASN1_ITEM ASN1_BMPSTRING_it;ASN1_ITEM ASN1_ANY_it;ASN1_ITEM ASN1_PRINTABLE_it;ASN1_ITEM DISPLAYTEXT_it;ASN1_ITEM DIRECTORYSTRING_it;ASN1_ITEM ASN1_SEQUENCE_ANY_it;ASN1_ITEM ASN1_SET_ANY_it;ASN1_ITEM PBEPARAM_it;ASN1_ITEM PBE2PARAM_it;ASN1_ITEM PBKDF2PARAM_it;void d2i_X509_REQ;void i2d_X509_REQ;void d2i_X509_CRL;void i2d_X509_CRL;void d2i_PKCS7;void i2d_PKCS7;void d2i_NETSCAPE_CERT_SEQUENCE;void i2d_NETSCAPE_CERT_SEQUENCE;void i2d_RSAPrivateKey;void d2i_RSAPublicKey;void i2d_RSAPublicKey;void d2i_RSA_PUBKEY;void i2d_RSA_PUBKEY;void i2d_DSAPrivateKey;void d2i_DSA_PUBKEY;void i2d_DSA_PUBKEY;void d2i_DSAparams;void i2d_DSAparams;void d2i_ECPKParameters;void i2d_ECPKParameters;void i2d_ECPrivateKey;void d2i_EC_PUBKEY;void i2d_EC_PUBKEY;void i2d_DHparams;void i2d_DHxparams;void d2i_PUBKEY;void i2d_PUBKEY;void i2d_PrivateKey;ASN1_ITEM PKCS7_it;ASN1_ITEM PKCS7_SIGNED_it;ASN1_ITEM PKCS7_SIGNER_INFO_it;ASN1_ITEM PKCS7_ISSUER_AND_SERIAL_it;ASN1_ITEM PKCS7_ENVELOPE_it;ASN1_ITEM PKCS7_RECIP_INFO_it;ASN1_ITEM PKCS7_ENC_CONTENT_it;ASN1_ITEM PKCS7_SIGN_ENVELOPE_it;ASN1_ITEM PKCS7_ENCRYPT_it;ASN1_ITEM PKCS7_DIGEST_it;ASN1_ITEM PKCS7_ATTR_SIGN_it;ASN1_ITEM PKCS7_ATTR_VERIFY_it;void X509_ATTRIBUTE_free;ASN1_ITEM X509_ALGORS_it;ASN1_ITEM PKCS12_it;ASN1_ITEM X509_it;ASN1_ITEM X509_CRL_it;ASN1_ITEM PKCS8_PRIV_KEY_INFO_it;stack_st_OPENSSL_STRING *app_locks;_func_CRYPTO_dynlock_value_ptr_char_ptr_int *dynlock_create_callback;_func_void_int_CRYPTO_dynlock_value_ptr_char_ptr_int *dynlock_lock_callback;_func_void_CRYPTO_dynlock_value_ptr_char_ptr_int *dynlock_destroy_callback;_func_void_int_int_char_ptr_int *locking_callback;_func_int_int_ptr_int_int_char_ptr_int *add_lock_callback;_func_void_CRYPTO_THREADID_ptr *threadid_callback;_func_ulong *id_callback;char *[41] lock_names;stack_st_CRYPTO_dynlock *dyn_locks;_func_void_ptr_size_t *malloc_func;_func_void_ptr_void_ptr_size_t *realloc_func;_func_void_ptr_size_t *malloc_locked_func;void default_malloc_locked_ex;int allow_customize;void default_malloc_ex;_func_void_void_ptr *free_locked_func;_func_void_ptr_size_t_char_ptr_int *malloc_ex_func;void default_realloc_ex;_func_void_ptr_void_ptr_size_t_char_ptr_int *realloc_ex_func;_func_void_ptr_size_t_char_ptr_int *malloc_locked_ex_func;int allow_customize_debug;_func_void_void_ptr_int_char_ptr_int_int *malloc_debug_func;_func_void_void_ptr_void_ptr_int_char_ptr_int_int *realloc_debug_func;_func_void_long *set_debug_options_func;_func_long *get_debug_options_func;lhash_st_APP_INFO *amih;long options;int mh_mode;uint num_disable;CRYPTO_THREADID disabling_threadid;void app_info_LHASH_COMP;void app_info_LHASH_HASH;void mem_LHASH_COMP;void mem_LHASH_HASH;lhash_st_MEM *mh;ulong order;void print_leak_LHASH_DOALL_ARG;void cb_leak_LHASH_DOALL_ARG;CRYPTO_EX_DATA_IMPL *impl;CRYPTO_EX_DATA_IMPL impl_default;int ex_class;lhash_st_EX_CLASS_ITEM *ex_data;void ex_class_item_LHASH_HASH;void ex_class_item_LHASH_COMP;void def_cleanup_cb;void def_cleanup_util_cb;int done;stack_st_NAME_FUNCS *name_funcs_stack;lhash_st_OBJ_NAME *names_lh;void obj_name_LHASH_COMP;void obj_name_LHASH_HASH;void strcmp;int names_type_num;void lh_strhash;int free_type;void do_all_fn_LHASH_DOALL_ARG;void do_all_sorted_fn;void do_all_sorted_cmp;void names_lh_free_LHASH_DOALL;void name_funcs_free;ASN1_OBJECT[958] nid_objs;void cleanup1_LHASH_DOALL;void cleanup2_LHASH_DOALL;void cleanup3_LHASH_DOALL;lhash_st_ADDED_OBJ *added;int new_nid;void added_obj_LHASH_COMP;void added_obj_LHASH_HASH;void obj_cmp_BSEARCH_CMP_FN;uint[890] obj_objs;void ln_cmp_BSEARCH_CMP_FN;uint[951] ln_objs;void sn_cmp_BSEARCH_CMP_FN;uint[951] sn_objs;void sig_cmp_BSEARCH_CMP_FN;stack_st_nid_triple *sig_app;nid_triple[40] sigoid_srt;void sigx_cmp_BSEARCH_CMP_FN;nid_triple *[37] sigoid_srt_xref;stack_st_nid_triple *sigx_app;void sig_sk_cmp;void sigx_cmp;void sid_free;uchar[64] m;void DAT_00070f00;uint32_t DAT_00071000;uint64_t DAT_00073620;void DAT_00073df0;void UNK_00073e00;void gcm_gmult_v8;void gcm_ghash_4bit;void gcm_gmult_4bit;void gcm_ghash_neon;void gcm_ghash_v8;void gcm_gmult_neon;uchar[8] default_iv;uint32_t rem_4bit;int bn_limit_bits;int bn_limit_bits_high;int bn_limit_bits_low;int bn_limit_bits_mont;BIGNUM const_one;uint8_t bits.9254;uint8_t DAT_001274e0;char[16] data;ASN1_ITEM X9_62_PENTANOMIAL_it;ASN1_ITEM X9_62_CHARACTERISTIC_TWO_it;ASN1_ITEM ECPARAMETERS_it;ASN1_ITEM ECPKPARAMETERS_it;ASN1_ITEM EC_PRIVATEKEY_it;RSA_METHOD rsa_pkcs1_eay_meth;ASN1_ITEM RSA_PSS_PARAMS_it;ASN1_ITEM RSA_OAEP_PARAMS_it;ASN1_ITEM RSAPrivateKey_it;ASN1_ITEM RSAPublicKey_it;DSA_METHOD *default_DSA_method;ASN1_ITEM DSA_SIG_it;ASN1_ITEM DSAPrivateKey_it;ASN1_ITEM DSAparams_it;ASN1_ITEM DSAPublicKey_it;DSA_METHOD openssl_dsa_meth;ASN1_ITEM DHparams_it;ASN1_ITEM DHxparams_it;DH_METHOD *default_DH_method;stack_st_ENGINE_CLEANUP_ITEM *cleanup_stack;void engine_cleanup_cb_free;int internal_static_hack;ENGINE *engine_list_head;ENGINE *engine_list_tail;void engine_list_cleanup;void DAT_001278ec;uint table_flags;void engine_pile_LHASH_HASH;void engine_pile_LHASH_COMP;void int_unregister_cb_LHASH_DOALL_ARG;void int_cleanup_cb_LHASH_DOALL;void int_cb_LHASH_DOALL_ARG;ENGINE_TABLE *dsa_table;void engine_unregister_all_DSA;ENGINE_TABLE *dh_table;void engine_unregister_all_DH;ENGINE_TABLE *rand_table;void engine_unregister_all_RAND;ENGINE_TABLE *cipher_table;void engine_unregister_all_ciphers;ENGINE_TABLE *pkey_meth_table;void engine_unregister_all_pkey_meths;ENGINE_TABLE *pkey_asn1_meth_table;void engine_unregister_all_pkey_asn1_meths;void look_str_cb;BIO_METHOD null_method;void DAT_00127974;void DAT_00127968;BIO_METHOD methods_filep;void DAT_00127994;uint crypto_lock_rand;CRYPTO_THREADID locking_threadid;int initialized;double entropy;uchar[1043] state;size_t state_num;size_t state_index;uchar[20] md;long[2] md_count;RAND_METHOD rand_ssleay_meth;int stirred_pool;char *[3] randomfiles;char *[5] egdsockets;uchar[128] data_ascii2bin;EVP_CIPHER des_cbc;EVP_CIPHER des_cfb64;EVP_CIPHER des_ofb;EVP_CIPHER des_ecb;EVP_CIPHER des_cfb1;EVP_CIPHER des_cfb8;EVP_CIPHER bf_cbc;EVP_CIPHER bf_cfb64;EVP_CIPHER bf_ofb;EVP_CIPHER bf_ecb;EVP_CIPHER idea_cbc;EVP_CIPHER idea_cfb64;EVP_CIPHER idea_ofb;EVP_CIPHER idea_ecb;EVP_CIPHER des_ede_cbc;EVP_CIPHER des_ede_cfb64;EVP_CIPHER des_ede_ofb;EVP_CIPHER des_ede_ecb;EVP_CIPHER des_ede3_cbc;EVP_CIPHER des_ede3_cfb64;EVP_CIPHER des_ede3_ofb;EVP_CIPHER des_ede3_ecb;EVP_CIPHER des_ede3_cfb1;EVP_CIPHER des_ede3_cfb8;EVP_CIPHER des3_wrap;void Camellia_decrypt;void Camellia_encrypt;void Camellia_cbc_encrypt;EVP_CIPHER camellia_128_cbc;EVP_CIPHER camellia_128_ecb;EVP_CIPHER camellia_128_ofb;EVP_CIPHER camellia_128_cfb;EVP_CIPHER camellia_128_cfb1;EVP_CIPHER camellia_128_cfb8;EVP_CIPHER camellia_192_cbc;EVP_CIPHER camellia_192_ecb;EVP_CIPHER camellia_192_ofb;EVP_CIPHER camellia_192_cfb;EVP_CIPHER camellia_192_cfb1;EVP_CIPHER camellia_192_cfb8;EVP_CIPHER camellia_256_cbc;EVP_CIPHER camellia_256_ecb;EVP_CIPHER camellia_256_ofb;EVP_CIPHER camellia_256_cfb;EVP_CIPHER camellia_256_cfb1;EVP_CIPHER camellia_256_cfb8;EVP_CIPHER r4_cipher;EVP_CIPHER r4_40_cipher;EVP_CIPHER seed_cbc;EVP_CIPHER seed_cfb128;EVP_CIPHER seed_ofb;EVP_CIPHER seed_ecb;EVP_CIPHER d_xcbc_cipher;EVP_CIPHER rc2_cbc;EVP_CIPHER rc2_cfb64;EVP_CIPHER rc2_ofb;EVP_CIPHER rc2_ecb;EVP_CIPHER r2_64_cbc_cipher;EVP_CIPHER r2_40_cbc_cipher;EVP_CIPHER cast5_cbc;EVP_CIPHER cast5_cfb64;EVP_CIPHER cast5_ofb;EVP_CIPHER cast5_ecb;EVP_MD md4_md;EVP_MD md5_md;EVP_MD sha_md;EVP_MD sha1_md;EVP_MD sha224_md;EVP_MD sha256_md;EVP_MD sha384_md;EVP_MD sha512_md;EVP_MD whirlpool_md;EVP_MD dsa_md;EVP_MD dss1_md;EVP_MD mdc2_md;EVP_MD ripemd160_md;EVP_MD ecdsa_md;BIO_METHOD methods_md;BIO_METHOD methods_enc;stack_st_EVP_PKEY_METHOD *app_pkey_methods;void pmeth_cmp_BSEARCH_CMP_FN;EVP_PKEY_METHOD *[7] standard_methods;void pmeth_cmp;ASN1_ITEM X509_ALGOR_it;ASN1_ITEM X509_PUBKEY_it;ASN1_ITEM X509_REQ_INFO_it;ASN1_ITEM X509_REQ_it;ASN1_ITEM X509_ATTRIBUTE_it;ASN1_ITEM X509_NAME_ENTRY_it;ASN1_ITEM X509_NAME_ENTRIES_it;void X509_NAME_ENTRY_free;void local_sk_X509_NAME_ENTRY_pop_free;ASN1_ITEM X509_NAME_INTERNAL_it;void local_sk_X509_NAME_ENTRY_free;ASN1_ITEM X509_NAME_it;ASN1_ITEM X509_CINF_it;ASN1_ITEM X509_CERT_AUX_it;void ASN1_OBJECT_free;ASN1_ITEM X509_CERT_PAIR_it;void X509_REVOKED_cmp;ASN1_ITEM X509_CRL_INFO_it;X509_CRL_METHOD *default_crl_method;void GENERAL_NAMES_free;ASN1_ITEM X509_REVOKED_it;X509_CRL_METHOD int_crl_meth;ASN1_ITEM NETSCAPE_CERT_SEQUENCE_it;void ASN1_TYPE_free;char[21] spaces;ASN1_PCTX default_pctx;stack_st_EVP_PKEY_ASN1_METHOD *app_methods;EVP_PKEY_ASN1_METHOD *[12] standard_methods;void ameth_cmp_BSEARCH_CMP_FN;void ameth_cmp;ASN1_ITEM X509_EXTENSION_it;ASN1_ITEM X509_EXTENSIONS_it;char *[31] tag2str;void d2i_X509_SIG;void i2d_X509_SIG;void d2i_PKCS8_PRIV_KEY_INFO;void i2d_PKCS8_PRIV_KEY_INFO;void X509_CRL_free;void X509_free;void get_issuer_sk;void check_revocation;void check_crl;void check_issued;void X509_STORE_CTX_get1_issuer;void check_policy;void cert_crl;void internal_verify;void X509_STORE_get1_crls;void null_callback;void X509_STORE_get1_certs;void x509_object_cmp;void cleanup;ASN1_ITEM NETSCAPE_SPKAC_it;void RSA_new;void DSA_new;void d2i_DSAPrivateKey;void EC_KEY_new;void d2i_ECPrivateKey;void X509_SIG_new;void PKCS8_PRIV_KEY_INFO_new;void d2i_AutoPrivateKey;void EVP_PKEY_new;_func_int_int_X509_ptr_int *default_trust;stack_st_X509_TRUST *trtable;X509_TRUST[8] trstandard;void tr_cmp;void trtable_free;X509V3_EXT_METHOD *[42] standard_exts;void str_free;void str_copy;void param_cmp;stack_st_X509_VERIFY_PARAM *param_table;X509_VERIFY_PARAM[5] default_table;void table_cmp_BSEARCH_CMP_FN;void X509_VERIFY_PARAM_free;void ext_cmp;stack_st_X509V3_EXT_METHOD *ext_list;void ext_cmp_BSEARCH_CMP_FN;void ext_list_free;void equal_nocase;void equal_email;void equal_case;void equal_wildcard;void X509V3_conf_free;void sk_strcmp;void GENERAL_NAME_free;void X509_EXTENSION_free;void ipv6_cb;ASN1_ITEM GENERAL_NAME_it;ASN1_ITEM OTHERNAME_it;ASN1_ITEM EDIPARTYNAME_it;ASN1_ITEM GENERAL_NAMES_it;void i2d_GENERAL_NAME;void d2i_GENERAL_NAME;void DAT_00128a7c;ASN1_ITEM PKEY_USAGE_PERIOD_it;ASN1_ITEM SXNETID_it;ASN1_ITEM SXNET_it;ASN1_ITEM POLICYINFO_it;ASN1_ITEM CERTIFICATEPOLICIES_it;ASN1_ITEM POLICYQUALINFO_it;ASN1_ITEM USERNOTICE_it;ASN1_ITEM NOTICEREF_it;void ASN1_STRING_free;void POLICYINFO_free;BIT_STRING_BITNAME[10] reason_flags;ASN1_ITEM DIST_POINT_it;ASN1_ITEM DIST_POINT_NAME_it;void DIST_POINT_free;ASN1_ITEM CRL_DIST_POINTS_it;ASN1_ITEM ISSUING_DIST_POINT_it;stack_st_X509_PURPOSE *xptable;X509_PURPOSE[9] xstandard;void xp_cmp;void xptable_free;void nid_cmp_BSEARCH_CMP_FN;int[11] supported_nids;ASN1_ITEM ACCESS_DESCRIPTION_it;void ACCESS_DESCRIPTION_free;ASN1_ITEM AUTHORITY_INFO_ACCESS_it;ASN1_ITEM AUTHORITY_KEYID_it;ASN1_ITEM POLICY_MAPPING_it;void POLICY_MAPPING_free;ASN1_ITEM POLICY_CONSTRAINTS_it;ASN1_ITEM GENERAL_SUBTREE_it;ASN1_ITEM NAME_CONSTRAINTS_it;ASN1_ITEM PROXY_POLICY_it;ASN1_ITEM PROXY_CERT_INFO_EXTENSION_it;void policy_data_free;void policy_data_cmp;void POLICYQUALINFO_free;void exnode_free;void policy_node_free;void SCT_free;stack_st_CONF_MODULE *supported_modules;stack_st_CONF_IMODULE *initialized_modules;ASN1_ITEM PKCS12_SAFEBAGS_it;ASN1_ITEM PKCS12_AUTHSAFES_it;ASN1_ITEM PKCS12_MAC_DATA_it;ASN1_ITEM PKCS12_BAGS_it;ASN1_ITEM PKCS12_SAFEBAG_it;ASN1_ITEM OCSP_SIGNATURE_it;ASN1_ITEM OCSP_CERTID_it;ASN1_ITEM OCSP_ONEREQ_it;ASN1_ITEM OCSP_REQINFO_it;ASN1_ITEM OCSP_REQUEST_it;ASN1_ITEM OCSP_RESPBYTES_it;ASN1_ITEM OCSP_RESPONSE_it;ASN1_ITEM OCSP_RESPID_it;ASN1_ITEM OCSP_REVOKEDINFO_it;ASN1_ITEM OCSP_CERTSTATUS_it;ASN1_ITEM OCSP_SINGLERESP_it;ASN1_ITEM OCSP_RESPDATA_it;ASN1_ITEM OCSP_BASICRESP_it;ASN1_ITEM OCSP_CRLID_it;ASN1_ITEM OCSP_SERVICELOC_it;void DAT_001299e8;void int_update;uchar[20] m;uchar[48] m;void K512;anon_union_16464_2_9473004f Cx;uchar[256] odd_parity;uchar[16][8] weak_keys;int[16] shifts2;uint[8][64] des_skb;int _shadow_DES_check_key;char[32] buf;uint[8][64] DES_SPtrans;uchar[256] key_table;BF_KEY bf_init;uint[256] CAST_S_table4;uint[256] CAST_S_table5;uint[256] CAST_S_table6;uint[256] CAST_S_table7;uint[256] CAST_S_table0;uint[256] CAST_S_table1;uint[256] CAST_S_table2;uint[256] CAST_S_table3;seed_word[4][256] SS;void SEED_decrypt;void SEED_encrypt;void BN_sub;void BN_add;void BN_pseudo_rand;void BN_rand;void ec_pre_comp_dup;void ec_pre_comp_free;void ec_pre_comp_clear_free;ec_list_element[81] curve_list;EC_NIST_NAME[15] nist_curves;EC_METHOD ret;ECDSA_METHOD *default_ECDSA_method;void ecdsa_data_free;void ecdsa_data_dup;ECDSA_METHOD openssl_ecdsa_meth;DH_METHOD dh_ossl;EVP_PKEY_ASN1_METHOD dhx_asn1_meth;BIGNUM _bignum_dh1024_160_p;BIGNUM _bignum_dh1024_160_q;BIGNUM _bignum_dh1024_160_g;BIGNUM _bignum_dh2048_224_g;BIGNUM _bignum_dh2048_224_p;BIGNUM _bignum_dh2048_224_q;BIGNUM _bignum_dh2048_256_p;BIGNUM _bignum_dh2048_256_q;BIGNUM _bignum_dh2048_256_g;uchar[4] ctr;DSO_METHOD *default_DSO_meth;DSO_METHOD dso_meth_dlfcn;ENGINE_TABLE *ecdsa_table;void engine_unregister_all_ECDSA;ENGINE_TABLE *digest_table;void engine_unregister_all_digests;void write_fp;void write_bio;char[80] prompt_string;void trans_cb;uint32_t max.10340;uint8_t[32] min.10339;uint8_t[36] min.10339;ASN1_ITEM ASN1_TIME_it;void SetBlobCmp;void DAT_00138544;void DAT_00138550;char[31] tag2nbyte;void DAT_00138554;void DAT_0013bbe4;void DAT_0013780c;void DAT_00138564;void DAT_00138568;void DAT_00138570;void DAT_0011caf8;void send_bio_chars;void send_fp_chars;ASN1_ITEM X509_VAL_it;ASN1_ITEM NETSCAPE_SPKI_it;char *[12] mon;void DAT_001388d8;void bitstr_cb;void asn1_cb;tag_name_st *tntmp;tag_name_st[49] tnst;ASN1_ITEM BASIC_CONSTRAINTS_it;void DAT_00138918;ulong global_mask;ASN1_STRING_TABLE[19] tbl_standard;stack_st_ASN1_STRING_TABLE *stable;void sk_table_cmp;void st_free;int *ext_nids;X509V3_CONF_METHOD nconf_method;X509V3_CONF_METHOD conf_lhash_method;ASN1_ITEM EXTENDED_KEY_USAGE_it;void node_cmp;CONF_METHOD *default_CONF_method;void conf_value_LHASH_HASH;void conf_value_LHASH_COMP;void value_free_stack_LHASH_DOALL;void value_free_hash_LHASH_DOALL_ARG;ushort[256] CONF_type_default;CONF_METHOD default_method;ushort[256] CONF_type_win32;CONF_METHOD WIN32_method;void dump_value_LHASH_DOALL_ARG;void free_string;void print_error;UI_METHOD *default_UI_meth;void DAT_00138fb8;sig_atomic_t intr_signal;uint32_t stdin;FILE *tty_in;FILE *tty_out;sigaction[32] savsig;void recsig;termio tty_new;termio tty_orig;int ps;int is_a_tty;UI_METHOD ui_openssl;ASN1_ITEM CMS_SharedInfo_it;ASN1_ITEM CMS_ContentInfo_it;void d2i_CMS_ContentInfo;void i2d_CMS_ContentInfo;ASN1_ITEM CMS_SignedData_it;ASN1_ITEM CMS_Attributes_Sign_it;ASN1_ITEM CMS_Attributes_Verify_it;ASN1_ITEM CMS_SignerInfo_it;void X509_ALGOR_free;ASN1_ITEM CMS_EnvelopedData_it;ASN1_ITEM CMS_KEKRecipientInfo_it;ASN1_ITEM CMS_OtherKeyAttribute_it;ASN1_ITEM CMS_RecipientInfo_it;uint8_t CSWTCH.8;ASN1_ITEM CMS_KeyTransRecipientInfo_it;ASN1_ITEM CMS_EncryptedData_it;ASN1_ITEM CMS_PasswordRecipientInfo_it;ASN1_ITEM CMS_RecipientKeyIdentifier_it;ASN1_ITEM CMS_KeyAgreeRecipientInfo_it;ASN1_ITEM CMS_RecipientEncryptedKey_it;ASN1_ITEM CMS_OriginatorPublicKey_it;uchar[32] zero_iv;u32[4][256] Camellia_SBOX;int[8] tab;prime_t[2048] primes;uint[16] SQR_tb;ASN1_ITEM ECDSA_SIG_it;ECDH_METHOD *default_ECDH_method;void ecdh_data_free;void ecdh_data_dup;ECDH_METHOD openssl_ecdh_meth;void DAT_0013b950;void dlfcn_pathbyaddr;ENGINE_TABLE *ecdh_table;void engine_unregister_all_ECDH;void print_fp;void print_bio;void out_utf8;void type_str;void in_utf8;void cpy_asc;void cpy_bmp;void cpy_univ;void cpy_utf8;void ndef_prefix_free;void ndef_suffix;void ndef_prefix;void ndef_suffix_free;void mime_param_free;void mime_param_cmp;void mime_hdr_cmp;void mime_hdr_free;void BIO_vfree;ASN1_ITEM CMS_CertificateChoices_it;ASN1_ITEM CMS_RevocationInfoChoice_it;ASN1_ITEM CMS_IssuerAndSerialNumber_it;ASN1_ITEM CMS_DigestedData_it;BIO_METHOD methods_buffer;BIO_METHOD methods_asn1;pointer __frame_dummy_init_array_entry;

UA_StatusCode readTimeData(void *handle, UA_NodeId nodeId, UA_Boolean sourceTimeStamp, UA_NumericRange *range, UA_DataValue *value, int index)
{  bool bVar1;  bool bVar2;  uint32_t uVar3;  UA_Byte *__dest;  size_t sVar4;  void *handle_local;  UA_Int32 out_27;
  UA_Int32 out_26;  double out_25;  double out_24;  double out_23;  double out_22;  double out_21;  ulong out_20;  double out_19;  double out_18;  float out_17;  float out_16;  float out_15;  float out_14;  float out_13;  float out_12;  ulong out_11;  float out_10;  float out_9;  float out_8;  float out_7;  float out_6;  float out_5;  float out_4;  ushort out_3;  float out_2;  float out_1;  uchar out;  UA_String greet;  uint32_t DataID;  int i;  int j;  char g_add_flag;  char flag;

  bVar2 = false;
  g_index_1 = nodeId.identifier.numeric;
  nodeId.identifier.numeric = nodeId.identifier.numeric - 0x1e240;
  uVar3 = nodeId.identifier.numeric;
  bVar1 = false;
  if (g_step_flag == 4)
  {
    j = 0;
    while (j < 0x1fe)
    {
      nodeId.identifierType = g_fetch_HMI_data_ID[j];
      if (nodeId.identifierType == uVar3)
      {
        bVar1 = false;
        break;
      }
      nodeId.identifier.numeric = g_fetch_HMI_data_ID[j];
      if (nodeId.identifier.numeric == 0)
      {
        bVar1 = true;
        nodeId.identifier.numeric = j + 1;
        g_fetch_HMI_data_count = nodeId.identifier.numeric;
        break;
      }
      nodeId.identifier.numeric = j + 1;
      j = nodeId.identifier.numeric;
    }
  }
  if (bVar1)
  {
    nodeId.identifierType = g_fetch_HMI_data_count + ~UA_NODEIDTYPE_NUMERIC;
    g_fetch_HMI_data_ID[nodeId.identifierType] = uVar3;
  }
  i = 0;
  do
  {
    if (0x1fd < i)
    {
    LAB_000166a4:
      if (!bVar2)
      {
        out_27 = 0xbde31;
        nodeId.identifier.numeric = (UA_UInt32)&value->value;
        nodeId._0_4_ = &out_27;
        UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 5);
      }
      *(byte *)value = *(byte *)value | 1;
      return 0;
    }
    nodeId.identifier.numeric = *(UA_UInt32 *)(&DAT_001594e8 + i * 0x40);
    if (nodeId.identifier.numeric == uVar3)
    {
      bVar2 = true;
      switch ((&DAT_001594f9)[i * 0x40])
      {
      case 1:
        nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
        greet.length = strlen((char *)nodeId.identifier.numeric);
        greet.data = malloc(0x28);
        memset(greet.data, 0, 0x28);
        __dest = greet.data;
        nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
        sVar4 = strlen((char *)nodeId.identifier.numeric);
        nodeId.identifier.numeric = sVar4 + 1;
        memcpy(__dest, &DBdata + i * 0x20, nodeId.identifier.numeric);
        nodeId.identifier.numeric = (UA_UInt32)&value->value;
        nodeId._0_4_ = &greet;
        UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 0xb);
        nodeId.identifier.numeric = (UA_UInt32)&greet;
        UA_String_deleteMembers((UA_String *)nodeId.identifier.numeric);
        break;
      case 2:
        if ((&DAT_001594f8)[i * 0x40] == '\0')
        {
          out = *(uchar *)(&DBdata + i * 0x20);
          nodeId.identifier.numeric = (UA_UInt32)&value->value;
          nodeId._0_4_ = &out;
          UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 3);
        }
        break;
      case 3:
      case 4:
        nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
        if (*(short *)nodeId.identifier.numeric == -1)
        {
          nodeId.identifierType = *(UA_NodeIdType *)(&DAT_001594e8 + i * 0x40);
          if ((nodeId.identifierType == 0xf2c1d) ||
              (nodeId.identifierType = *(UA_NodeIdType *)(&DAT_001594e8 + i * 0x40),
               nodeId.identifierType == 0xf2c1c))
          {
            out_1 = 1.0;
          }
          else
          {
            out_1 = -1.0;
          }
          nodeId.identifier.numeric = (UA_UInt32)&value->value;
          nodeId._0_4_ = &out_1;
          UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
        }
        else
        {
          if (((&DAT_001594f8)[i * 0x40] == '\0') && (0x1e < i))
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_2 = (float)*(ushort *)nodeId.identifier.numeric;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_2;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          else if (((&DAT_001594f8)[i * 0x40] == '\0') && (i < 0x1f))
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_3 = *(ushort *)nodeId.identifier.numeric;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_3;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 4);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x01')
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_4 = (float)*(ushort *)nodeId.identifier.numeric / 10.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_4;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x02')
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_5 = (float)*(ushort *)nodeId.identifier.numeric / 100.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_5;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x03')
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_6 = (float)*(ushort *)nodeId.identifier.numeric / 1000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_6;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x04')
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_7 = (float)*(ushort *)nodeId.identifier.numeric / 10000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_7;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x05')
          {
            nodeId.identifier.numeric = (UA_UInt32)(&DBdata + i * 0x20);
            out_8 = (float)*(ushort *)nodeId.identifier.numeric / 100000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_8;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
        }
        break;
      case 5:
        nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
        if ((nodeId.identifier.numeric == 0xffffffff) ||
            (nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20),
             nodeId.identifier.numeric == 0xffff))
        {
          out_9 = -1.0;
          nodeId.identifier.numeric = (UA_UInt32)&value->value;
          nodeId._0_4_ = &out_9;
          UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
        }
        else
        {
          if (((&DAT_001594f8)[i * 0x40] == '\0') && (0x1e < i))
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_10 = (float)nodeId.identifier._0_4_;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_10;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          else if (((&DAT_001594f8)[i * 0x40] == '\0') && (i < 0x1f))
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_11 = nodeId.identifier.numeric;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_11;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 6);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x01')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_12 = (float)nodeId.identifier._0_4_ / 10.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_12;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x02')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_13 = (float)nodeId.identifier._0_4_ / 100.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_13;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x03')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_14 = (float)nodeId.identifier._0_4_ / 1000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_14;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x04')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_15 = (float)nodeId.identifier._0_4_ / 10000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_15;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x05')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_16 = (float)nodeId.identifier._0_4_ / 100000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_16;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
          }
        }
        break;
      default:
        out_26 = 0xa2c2a;
        nodeId.identifier.numeric = (UA_UInt32)&value->value;
        nodeId._0_4_ = &out_26;
        UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 5);
        break;
      case 8:
        out_17 = -1.0;
        nodeId.identifier.numeric = (UA_UInt32)&value->value;
        nodeId._0_4_ = &out_17;
        UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 9);
        break;
      case 0xd:
        nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
        if ((nodeId.identifier.numeric == 0xffffffff) ||
            (nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20),
             nodeId.identifier.numeric == 0xffff))
        {
          out_18._0_4_ = 0;
          out_18._4_4_ = 0xbff00000;
          nodeId.identifier.numeric = (UA_UInt32)&value->value;
          nodeId._0_4_ = &out_18;
          UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
        }
        else
        {
          if (((&DAT_001594f8)[i * 0x40] == '\0') && (0x1e < i))
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_19 = (double)nodeId.identifier._0_4_;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_19;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
          else if (((&DAT_001594f8)[i * 0x40] == '\0') && (i < 0x1f))
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_20 = nodeId.identifier.numeric;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_20;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 6);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x01')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_21 = (double)nodeId.identifier._0_4_ / 10.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_21;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x02')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_22 = (double)nodeId.identifier._0_4_ / 100.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_22;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x03')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_23 = (double)nodeId.identifier._0_4_ / 1000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_23;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x04')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_24 = (double)nodeId.identifier._0_4_ / 10000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_24;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
          if ((&DAT_001594f8)[i * 0x40] == '\x05')
          {
            nodeId.identifier.numeric = *(UA_UInt32 *)(&DBdata + i * 0x20);
            out_25 = (double)nodeId.identifier._0_4_ / 100000.0;
            nodeId.identifier.numeric = (UA_UInt32)&value->value;
            nodeId._0_4_ = &out_25;
            UA_Variant_setScalarCopy((UA_Variant *)nodeId.identifier.numeric, (void *)nodeId._0_4_, UA_TYPES + 10);
          }
        }
      }
      goto LAB_000166a4;
    }
    nodeId.identifier.numeric = i + 1;
    i = nodeId.identifier.numeric;
  } while (true);
}

UA_StatusCode
helloWorld(void *methodHandle, UA_NodeId objectId, size_t inputSize, UA_Variant *input,
           size_t outputSize, UA_Variant *output)

{
  uint32_t uVar1;
  void *methodHandle_local;
  UA_String greet;
  UA_String hello;
  UA_String *name;

  objectId.identifier.numeric = (UA_UInt32)input->data;
  uVar1 = objectId.identifier.numeric;
  objectId.identifier.numeric = (UA_UInt32)&hello;
  UA_STRING((UA_String *)objectId.identifier.numeric, "Hello ");
  objectId.identifier.numeric = *(UA_UInt32 *)uVar1;
  objectId.identifier.numeric = hello.length + objectId.identifier.numeric;
  greet.length = objectId.identifier.string.length;
  greet.data = malloc(objectId.identifier.numeric);
  memcpy(greet.data, hello.data, hello.length);
  objectId._0_4_ = *(uint32_t *)(uVar1 + 4);
  objectId.identifier.numeric = *(UA_UInt32 *)uVar1;
  memcpy(greet.data + hello.length, (void *)objectId._0_4_, objectId.identifier.numeric);
  objectId.identifier.numeric = (UA_UInt32)&greet;
  UA_Variant_setScalarCopy(output, (void *)objectId.identifier.numeric, UA_TYPES + 0xb);
  objectId.identifier.numeric = (UA_UInt32)&greet;
  UA_String_deleteMembers((UA_String *)objectId.identifier.numeric);
  return 0;
}

int main(int argc, char **argv)
{
  UA_LocalizedText displayName;  UA_NodeId parentNodeId;  UA_NodeId parentNodeId_00;  UA_NodeId parentNodeId_01;  UA_NodeId parentNodeId_02;  UA_NodeId parentNodeId_03;  UA_NodeId parentNodeId_04;  UA_NodeId referenceTypeId;  UA_NodeId referenceTypeId_00;  UA_NodeId referenceTypeId_01;  UA_NodeId referenceTypeId_02;  UA_NodeId referenceTypeId_03;  UA_NodeId referenceTypeId_04;  UA_NodeId referenceTypeId_05;  UA_NodeId referenceTypeId_06;  UA_QualifiedName browseName;  UA_QualifiedName browseName_00;  UA_QualifiedName browseName_01;  UA_QualifiedName browseName_02;  UA_QualifiedName browseName_03;  UA_QualifiedName browseName_04;  UA_QualifiedName browseName_05;  UA_QualifiedName browseName_06;  UA_NodeId typeDefinition;  UA_NodeId typeDefinition_00;  UA_NodeId typeDefinition_01;  UA_NodeId typeDefinition_02;  UA_NodeId typeDefinition_03;  UA_NodeId typeDefinition_04;  UA_NodeId typeDefinition_05;  UA_NodeId typeDefinition_06;  UA_ObjectAttributes attr;  UA_ObjectAttributes attr_00;  UA_ObjectAttributes attr_01;  UA_ObjectAttributes attr_02;  UA_ObjectAttributes attr_03;  UA_ObjectAttributes attr_04;  UA_ObjectAttributes attr_05;  UA_VariableAttributes attr_06;  UA_DataSource dataSource;  UA_UInt16 UVar44;  int iVar1;  UA_UInt16 UVar47;  UA_UInt16 UVar52;  UA_UInt16 UVar53;  UA_UInt16 UVar54;  UA_UInt16 UVar48;  UA_UInt16 UVar49;  UA_UInt16 UVar50;  UA_UInt32 UVar55;  UA_UInt32 UVar65;  unkbyte10 Var45;  void6 uVar57;  void6 uVar58;  void6 uVar59;  void6 uVar60;  void6 uVar62;  void6 uVar63;  void6 uVar64;  UA_UInt32 UVar2;  UA_Byte *pUVar3;  uint32_t uVar5;  uint32_t uVar6;  uint32_t uVar7;  uint32_t uVar8;  uint32_t uVar10;  uint32_t uVar11;  uint32_t uVar12;  UA_NodeId UVar13;  UA_NodeId UVar14;  UA_ConnectionConfig conf;  UA_ServerConfig config_00;  uint8_t auVar15[12];  uint64_t uVar66;  uint64_t uVar67;  uint64_t uVar68;  uint64_t uVar69;  uint64_t uVar70;  uint64_t uVar71;  uint64_t uVar72;  uint64_t uVar73;  uint64_t uVar74;  uint64_t uVar75;  uint8_t auVar16[220];  uint8_t auVar76[12];  anon_union_16_4_621dfe33_for_identifier aVar17;  anon_union_16_4_621dfe33_for_identifier aVar18;  anon_union_16_4_621dfe33_for_identifier aVar19;  anon_union_16_4_621dfe33_for_identifier aVar20;  anon_union_16_4_621dfe33_for_identifier aVar21;  anon_union_16_4_621dfe33_for_identifier aVar22;  anon_union_16_4_621dfe33_for_identifier aVar23;  anon_union_16_4_621dfe33_for_identifier aVar24;  anon_union_16_4_621dfe33_for_identifier aVar25;  uint8_t in_stack_00000000[216];  UA_Byte *local_698;  UA_UInt32 UStackY_694;  UA_UInt32 UVar26;  size_t sVar27;  UA_Byte *pUVar28;  size_t sVar29;  UA_Byte *pUVar30;  size_t sVar31;  UA_Byte *pUVar32;  size_t sVar33;  UA_Byte *pUVar34;  UA_UInt32 UVar35;  UA_UInt32 UVar36;  uint32_t uVar37;  uint32_t uVar38;  uint32_t uVar39;  uint8_t auVar40[24];  uint8_t in_stack_fffffa00[72];  uint32_t uVar41;  code *pcVar42;  _func_UA_StatusCode_void_ptr_UA_NodeId_UA_Variant_ptr_UA_NumericRange_ptr *p_Var43;  UA_NodeId *outNewNodeId;  UA_UInt32 index;  UA_LocalizedText local_5a0;  UA_ByteString local_590;  char **argv_local;  int argc_local;  UA_VariableAttributes attr1;  UA_QualifiedName dateName;  UA_NodeId dataSourceId;  UA_DataSource dateDataSource;  UA_LocalizedText objectsName;  char cHMI1[20];  UA_ObjectAttributes object_attr;  UA_ServerConfig config;  UA_ServerNetworkLayer nl;  UA_NodeId local_370;  UA_NodeId local_358;  UA_NodeId local_340;  UA_QualifiedName local_328;  UA_NodeId local_31c;  UA_NodeId local_304;  UA_NodeId local_2ec;  UA_NodeId local_2d4;  UA_QualifiedName local_2bc;  UA_NodeId local_2b0;  UA_NodeId local_298;  UA_NodeId local_280;  UA_NodeId local_268;  UA_QualifiedName local_250;  UA_NodeId local_244;  UA_NodeId local_22c;  UA_NodeId local_214;  UA_NodeId local_1fc;  UA_QualifiedName local_1e4;  UA_NodeId local_1d8;  UA_NodeId local_1c0;  UA_NodeId local_1a8;  UA_NodeId local_190;  UA_QualifiedName local_178;  UA_NodeId local_16c;  UA_NodeId local_154;  UA_NodeId local_13c;  UA_NodeId local_124;  UA_QualifiedName local_10c;  UA_NodeId local_100;  UA_NodeId local_e8;  UA_NodeId local_d0;  UA_NodeId local_b8;  UA_QualifiedName local_a0;  UA_NodeId local_94;  UA_NodeId local_7c;  UA_NodeId local_64;  UA_NodeId local_4c;  UA_NodeId local_34;  UA_StatusCode retval;  UA_UInt32 id;  UA_Server *server;  UA_UInt32 type;  int i;  UA_UInt16 UVar46;  UA_UInt16 UVar51;  void6 uVar56;  void6 uVar61;  uint32_t uVar4;  uint32_t uVar9;

  argv_local = argv;
  argc_local = argc;
  iVar1 = access("../test_file1.log", 0);
  if (iVar1 == 0)
  {
    system("rm -rf ../test_file1.log");
  }
  logInit("../test_file1.log");
  logSetFlags(0x1f9);
  pthread_create(&ntid_hmi, (pthread_attr_t *)0x0, pthread_inet, (void *)0x0);
  InitTimer();
  AddDnCounter(&g_send_to_hmi_time);
  AddDnCounter(&g_send_to_hmi_time_string);
  AddDnCounter(&g_send_to_hmi_heartbeat);
  AddDnCounter(&g_send_to_hmi_offline);
  signal(2, stopHandler);
  local_698 = (UA_Byte *)0;
  UStackY_694 = 0;
  UVar2 = 0xffff;
  auVar15 = CONCAT84(auVar15._4_8_, UVar2);
  UVar55 = 0;
  register0x00000028 = 0xffff;
  conf = (UA_ConnectionConfig)CONCAT128(auVar15, uVar66);
  UA_ServerNetworkLayerTCP(&nl, conf, 0x4118);
  memcpy(&config, &UA_ServerConfig_standard, 0xe8);
  config.networkLayers = &nl;
  config.networkLayersSize = 1;
  memset(g_fetch_HMI_data_ID, 0, 0x7f8);
  loadCertificate(&local_590);
  config.serverCertificate.length = local_590.length;
  config.serverCertificate.data = local_590.data;
  memcpy(&local_698, &config.buildInfo.manufacturerName, 0xd8);
  pUVar3 = config.buildInfo.productUri.data;
  auVar16 = CONCAT2164(in_stack_00000000, pUVar3);
  UVar44 = config.nThreads;
  Var45._2_2_ = config._2_2_;
  Var45._4_4_ = config.logger;
  register0x00000028 = config.buildInfo.productUri.length;
  config_00 = (UA_ServerConfig)CONCAT22012(auVar16, auVar76);
  server = UA_Server_new(config_00);
  UA_ObjectAttributes_init(&object_attr);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", "Demo");
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_001090e8);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_370, 1, 50000);
  UA_NODEID_NUMERIC(&local_358, 0, 0x55);
  UA_NODEID_NUMERIC(&local_340, 0, 0x23);
  UA_QUALIFIEDNAME(&local_328, 1, "Demo");
  UA_NODEID_NUMERIC(&local_31c, 0, 0x3d);
  local_698 = local_370.identifier.string.data;
  UStackY_694 = local_370.identifier._8_4_;
  UVar14.identifierType = local_358.identifierType;
  UVar14.namespaceIndex = local_358.namespaceIndex;
  UVar14._2_2_ = local_358._2_2_;
  UVar14.identifier.numeric = local_358.identifier.numeric;
  UVar14.identifier.string.data = local_358.identifier.string.data;
  UVar14.identifier._8_4_ = local_358.identifier._8_4_;
  UVar14.identifier._12_4_ = local_358.identifier._12_4_;
  referenceTypeId.identifierType = local_340.identifierType;
  referenceTypeId.namespaceIndex = local_340.namespaceIndex;
  referenceTypeId._2_2_ = local_340._2_2_;
  referenceTypeId.identifier.numeric = local_340.identifier.numeric;
  referenceTypeId.identifier.string.data = local_340.identifier.string.data;
  referenceTypeId.identifier._8_4_ = local_340.identifier._8_4_;
  referenceTypeId.identifier._12_4_ = local_340.identifier._12_4_;
  browseName.name.length = local_328.name.length;
  browseName.namespaceIndex = local_328.namespaceIndex;
  browseName._2_2_ = local_328._2_2_;
  browseName.name.data = local_328.name.data;
  typeDefinition.identifierType = local_31c.identifierType;
  typeDefinition.namespaceIndex = local_31c.namespaceIndex;
  typeDefinition._2_2_ = local_31c._2_2_;
  typeDefinition.identifier.numeric = local_31c.identifier.numeric;
  typeDefinition.identifier.string.data = local_31c.identifier.string.data;
  typeDefinition.identifier._8_4_ = local_31c.identifier._8_4_;
  typeDefinition.identifier._12_4_ = local_31c.identifier._12_4_;
  attr.displayName.locale.length = object_attr.displayName.locale.length;
  attr.specifiedAttributes = object_attr.specifiedAttributes;
  attr.displayName.locale.data = object_attr.displayName.locale.data;
  attr.displayName.text.length = object_attr.displayName.text.length;
  attr.displayName.text.data = object_attr.displayName.text.data;
  attr.description.locale.length = object_attr.description.locale.length;
  attr.description.locale.data = object_attr.description.locale.data;
  attr.description.text.length = object_attr.description.text.length;
  attr.description.text.data = object_attr.description.text.data;
  attr.writeMask = object_attr.writeMask;
  attr.userWriteMask = object_attr.userWriteMask;
  attr.eventNotifier = object_attr.eventNotifier;
  attr._45_3_ = object_attr._45_3_;
  UVar13.identifier._4_12_ = SUB21612(in_stack_00000000, 0);
  uVar4 = local_370.identifier.numeric;
  aVar17 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar4);
  UVar46 = local_370.namespaceIndex;
  uVar56._2_2_ = local_370._2_2_;
  register0x00000028 = local_370.identifierType;
  UVar13 = (UA_NodeId)CONCAT168(aVar17, uVar67);
  UA_Server_addObjectNode(server, UVar13, UVar14, referenceTypeId, browseName, typeDefinition, attr,
                          (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  sprintf(cHMI1, "HMI1 %s", &DAT_0010911c);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", "HMI1");
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", cHMI1);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_304, 1, 0x15f91);
  UA_NODEID_NUMERIC(&local_2ec, 1, 50000);
  UA_NODEID_NUMERIC(&local_2d4, 0, 0x23);
  UA_QUALIFIEDNAME(&local_2bc, 1, "HMI1");
  UA_NODEID_NUMERIC(&local_2b0, 0, 0x3d);
  local_698 = local_304.identifier.string.data;
  UStackY_694 = local_304.identifier._8_4_;
  UVar13.identifierType = local_2ec.identifierType;
  UVar13.namespaceIndex = local_2ec.namespaceIndex;
  UVar13._2_2_ = local_2ec._2_2_;
  UVar13.identifier.numeric = local_2ec.identifier.numeric;
  UVar13.identifier.string.data = local_2ec.identifier.string.data;
  UVar13.identifier._8_4_ = local_2ec.identifier._8_4_;
  UVar13.identifier._12_4_ = local_2ec.identifier._12_4_;
  referenceTypeId_00.identifierType = local_2d4.identifierType;
  referenceTypeId_00.namespaceIndex = local_2d4.namespaceIndex;
  referenceTypeId_00._2_2_ = local_2d4._2_2_;
  referenceTypeId_00.identifier.numeric = local_2d4.identifier.numeric;
  referenceTypeId_00.identifier.string.data = local_2d4.identifier.string.data;
  referenceTypeId_00.identifier._8_4_ = local_2d4.identifier._8_4_;
  referenceTypeId_00.identifier._12_4_ = local_2d4.identifier._12_4_;
  browseName_00.name.length = local_2bc.name.length;
  browseName_00.namespaceIndex = local_2bc.namespaceIndex;
  browseName_00._2_2_ = local_2bc._2_2_;
  browseName_00.name.data = local_2bc.name.data;
  typeDefinition_00.identifierType = local_2b0.identifierType;
  typeDefinition_00.namespaceIndex = local_2b0.namespaceIndex;
  typeDefinition_00._2_2_ = local_2b0._2_2_;
  typeDefinition_00.identifier.numeric = local_2b0.identifier.numeric;
  typeDefinition_00.identifier.string.data = local_2b0.identifier.string.data;
  typeDefinition_00.identifier._8_4_ = local_2b0.identifier._8_4_;
  typeDefinition_00.identifier._12_4_ = local_2b0.identifier._12_4_;
  attr_00.displayName.locale.length = object_attr.displayName.locale.length;
  attr_00.specifiedAttributes = object_attr.specifiedAttributes;
  attr_00.displayName.locale.data = object_attr.displayName.locale.data;
  attr_00.displayName.text.length = object_attr.displayName.text.length;
  attr_00.displayName.text.data = object_attr.displayName.text.data;
  attr_00.description.locale.length = object_attr.description.locale.length;
  attr_00.description.locale.data = object_attr.description.locale.data;
  attr_00.description.text.length = object_attr.description.text.length;
  attr_00.description.text.data = object_attr.description.text.data;
  attr_00.writeMask = object_attr.writeMask;
  attr_00.userWriteMask = object_attr.userWriteMask;
  attr_00.eventNotifier = object_attr.eventNotifier;
  attr_00._45_3_ = object_attr._45_3_;
  uVar5 = local_304.identifier.numeric;
  aVar18 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar5);
  UVar47 = local_304.namespaceIndex;
  uVar57._2_2_ = local_304._2_2_;
  register0x00000028 = local_304.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar18, uVar68);
  UA_Server_addObjectNode(server, UVar14, UVar13, referenceTypeId_00, browseName_00, typeDefinition_00, attr_00,
                          (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_00109138);
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_0010914c);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_298, 1, 0x2e694);
  UA_NODEID_NUMERIC(&local_280, 1, 0x15f91);
  UA_NODEID_NUMERIC(&local_268, 0, 0x23);
  UA_QUALIFIEDNAME(&local_250, 1, &DAT_00109138);
  UA_NODEID_NUMERIC(&local_244, 0, 0x3d);
  local_698 = local_298.identifier.string.data;
  UStackY_694 = local_298.identifier._8_4_;
  parentNodeId.identifierType = local_280.identifierType;
  parentNodeId.namespaceIndex = local_280.namespaceIndex;
  parentNodeId._2_2_ = local_280._2_2_;
  parentNodeId.identifier.numeric = local_280.identifier.numeric;
  parentNodeId.identifier.string.data = local_280.identifier.string.data;
  parentNodeId.identifier._8_4_ = local_280.identifier._8_4_;
  parentNodeId.identifier._12_4_ = local_280.identifier._12_4_;
  referenceTypeId_01.identifierType = local_268.identifierType;
  referenceTypeId_01.namespaceIndex = local_268.namespaceIndex;
  referenceTypeId_01._2_2_ = local_268._2_2_;
  referenceTypeId_01.identifier.numeric = local_268.identifier.numeric;
  referenceTypeId_01.identifier.string.data = local_268.identifier.string.data;
  referenceTypeId_01.identifier._8_4_ = local_268.identifier._8_4_;
  referenceTypeId_01.identifier._12_4_ = local_268.identifier._12_4_;
  browseName_01.name.length = local_250.name.length;
  browseName_01.namespaceIndex = local_250.namespaceIndex;
  browseName_01._2_2_ = local_250._2_2_;
  browseName_01.name.data = local_250.name.data;
  typeDefinition_01.identifierType = local_244.identifierType;
  typeDefinition_01.namespaceIndex = local_244.namespaceIndex;
  typeDefinition_01._2_2_ = local_244._2_2_;
  typeDefinition_01.identifier.numeric = local_244.identifier.numeric;
  typeDefinition_01.identifier.string.data = local_244.identifier.string.data;
  typeDefinition_01.identifier._8_4_ = local_244.identifier._8_4_;
  typeDefinition_01.identifier._12_4_ = local_244.identifier._12_4_;
  attr_01.displayName.locale.length = object_attr.displayName.locale.length;
  attr_01.specifiedAttributes = object_attr.specifiedAttributes;
  attr_01.displayName.locale.data = object_attr.displayName.locale.data;
  attr_01.displayName.text.length = object_attr.displayName.text.length;
  attr_01.displayName.text.data = object_attr.displayName.text.data;
  attr_01.description.locale.length = object_attr.description.locale.length;
  attr_01.description.locale.data = object_attr.description.locale.data;
  attr_01.description.text.length = object_attr.description.text.length;
  attr_01.description.text.data = object_attr.description.text.data;
  attr_01.writeMask = object_attr.writeMask;
  attr_01.userWriteMask = object_attr.userWriteMask;
  attr_01.eventNotifier = object_attr.eventNotifier;
  attr_01._45_3_ = object_attr._45_3_;
  uVar6 = local_298.identifier.numeric;
  aVar19 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar6);
  UVar48 = local_298.namespaceIndex;
  uVar58._2_2_ = local_298._2_2_;
  register0x00000028 = local_298.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar19, uVar69);
  UA_Server_addObjectNode(server, UVar14, parentNodeId, referenceTypeId_01, browseName_01, typeDefinition_01, attr_01,
                          (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_00109168);
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_00109184);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_22c, 1, 0x2e695);
  UA_NODEID_NUMERIC(&local_214, 1, 0x15f91);
  UA_NODEID_NUMERIC(&local_1fc, 0, 0x23);
  UA_QUALIFIEDNAME(&local_1e4, 1, &DAT_00109168);
  UA_NODEID_NUMERIC(&local_1d8, 0, 0x3d);
  local_698 = local_22c.identifier.string.data;
  UStackY_694 = local_22c.identifier._8_4_;
  parentNodeId_00.identifierType = local_214.identifierType;
  parentNodeId_00.namespaceIndex = local_214.namespaceIndex;
  parentNodeId_00._2_2_ = local_214._2_2_;
  parentNodeId_00.identifier.numeric = local_214.identifier.numeric;
  parentNodeId_00.identifier.string.data = local_214.identifier.string.data;
  parentNodeId_00.identifier._8_4_ = local_214.identifier._8_4_;
  parentNodeId_00.identifier._12_4_ = local_214.identifier._12_4_;
  referenceTypeId_02.identifierType = local_1fc.identifierType;
  referenceTypeId_02.namespaceIndex = local_1fc.namespaceIndex;
  referenceTypeId_02._2_2_ = local_1fc._2_2_;
  referenceTypeId_02.identifier.numeric = local_1fc.identifier.numeric;
  referenceTypeId_02.identifier.string.data = local_1fc.identifier.string.data;
  referenceTypeId_02.identifier._8_4_ = local_1fc.identifier._8_4_;
  referenceTypeId_02.identifier._12_4_ = local_1fc.identifier._12_4_;
  browseName_02.name.length = local_1e4.name.length;
  browseName_02.namespaceIndex = local_1e4.namespaceIndex;
  browseName_02._2_2_ = local_1e4._2_2_;
  browseName_02.name.data = local_1e4.name.data;
  typeDefinition_02.identifierType = local_1d8.identifierType;
  typeDefinition_02.namespaceIndex = local_1d8.namespaceIndex;
  typeDefinition_02._2_2_ = local_1d8._2_2_;
  typeDefinition_02.identifier.numeric = local_1d8.identifier.numeric;
  typeDefinition_02.identifier.string.data = local_1d8.identifier.string.data;
  typeDefinition_02.identifier._8_4_ = local_1d8.identifier._8_4_;
  typeDefinition_02.identifier._12_4_ = local_1d8.identifier._12_4_;
  attr_02.displayName.locale.length = object_attr.displayName.locale.length;
  attr_02.specifiedAttributes = object_attr.specifiedAttributes;
  attr_02.displayName.locale.data = object_attr.displayName.locale.data;
  attr_02.displayName.text.length = object_attr.displayName.text.length;
  attr_02.displayName.text.data = object_attr.displayName.text.data;
  attr_02.description.locale.length = object_attr.description.locale.length;
  attr_02.description.locale.data = object_attr.description.locale.data;
  attr_02.description.text.length = object_attr.description.text.length;
  attr_02.description.text.data = object_attr.description.text.data;
  attr_02.writeMask = object_attr.writeMask;
  attr_02.userWriteMask = object_attr.userWriteMask;
  attr_02.eventNotifier = object_attr.eventNotifier;
  attr_02._45_3_ = object_attr._45_3_;
  uVar7 = local_22c.identifier.numeric;
  aVar20 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar7);
  UVar49 = local_22c.namespaceIndex;
  uVar59._2_2_ = local_22c._2_2_;
  register0x00000028 = local_22c.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar20, uVar70);
  UA_Server_addObjectNode(server, UVar14, parentNodeId_00, referenceTypeId_02, browseName_02, typeDefinition_02,
                          attr_02, (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_001091a8);
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_001091b0);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_1c0, 1, 0x2e697);
  UA_NODEID_NUMERIC(&local_1a8, 1, 0x15f91);
  UA_NODEID_NUMERIC(&local_190, 0, 0x23);
  UA_QUALIFIEDNAME(&local_178, 1, &DAT_001091a8);
  UA_NODEID_NUMERIC(&local_16c, 0, 0x3d);
  local_698 = local_1c0.identifier.string.data;
  UStackY_694 = local_1c0.identifier._8_4_;
  parentNodeId_01.identifierType = local_1a8.identifierType;
  parentNodeId_01.namespaceIndex = local_1a8.namespaceIndex;
  parentNodeId_01._2_2_ = local_1a8._2_2_;
  parentNodeId_01.identifier.numeric = local_1a8.identifier.numeric;
  parentNodeId_01.identifier.string.data = local_1a8.identifier.string.data;
  parentNodeId_01.identifier._8_4_ = local_1a8.identifier._8_4_;
  parentNodeId_01.identifier._12_4_ = local_1a8.identifier._12_4_;
  referenceTypeId_03.identifierType = local_190.identifierType;
  referenceTypeId_03.namespaceIndex = local_190.namespaceIndex;
  referenceTypeId_03._2_2_ = local_190._2_2_;
  referenceTypeId_03.identifier.numeric = local_190.identifier.numeric;
  referenceTypeId_03.identifier.string.data = local_190.identifier.string.data;
  referenceTypeId_03.identifier._8_4_ = local_190.identifier._8_4_;
  referenceTypeId_03.identifier._12_4_ = local_190.identifier._12_4_;
  browseName_03.name.length = local_178.name.length;
  browseName_03.namespaceIndex = local_178.namespaceIndex;
  browseName_03._2_2_ = local_178._2_2_;
  browseName_03.name.data = local_178.name.data;
  typeDefinition_03.identifierType = local_16c.identifierType;
  typeDefinition_03.namespaceIndex = local_16c.namespaceIndex;
  typeDefinition_03._2_2_ = local_16c._2_2_;
  typeDefinition_03.identifier.numeric = local_16c.identifier.numeric;
  typeDefinition_03.identifier.string.data = local_16c.identifier.string.data;
  typeDefinition_03.identifier._8_4_ = local_16c.identifier._8_4_;
  typeDefinition_03.identifier._12_4_ = local_16c.identifier._12_4_;
  attr_03.displayName.locale.length = object_attr.displayName.locale.length;
  attr_03.specifiedAttributes = object_attr.specifiedAttributes;
  attr_03.displayName.locale.data = object_attr.displayName.locale.data;
  attr_03.displayName.text.length = object_attr.displayName.text.length;
  attr_03.displayName.text.data = object_attr.displayName.text.data;
  attr_03.description.locale.length = object_attr.description.locale.length;
  attr_03.description.locale.data = object_attr.description.locale.data;
  attr_03.description.text.length = object_attr.description.text.length;
  attr_03.description.text.data = object_attr.description.text.data;
  attr_03.writeMask = object_attr.writeMask;
  attr_03.userWriteMask = object_attr.userWriteMask;
  attr_03.eventNotifier = object_attr.eventNotifier;
  attr_03._45_3_ = object_attr._45_3_;
  uVar8 = local_1c0.identifier.numeric;
  aVar21 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar8);
  UVar50 = local_1c0.namespaceIndex;
  uVar60._2_2_ = local_1c0._2_2_;
  register0x00000028 = local_1c0.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar21, uVar71);
  UA_Server_addObjectNode(server, UVar14, parentNodeId_01, referenceTypeId_03, browseName_03, typeDefinition_03,
                          attr_03, (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_001091d0);
  object_attr.description.locale.length = local_5a0.locale.length;
  object_attr.description.locale.data = local_5a0.locale.data;
  object_attr.description.text.length = local_5a0.text.length;
  object_attr.description.text.data = local_5a0.text.data;
  UA_LOCALIZEDTEXT(&local_5a0, "en_US", &DAT_001091e4);
  object_attr.displayName.locale.length = local_5a0.locale.length;
  object_attr.displayName.locale.data = local_5a0.locale.data;
  object_attr.displayName.text.length = local_5a0.text.length;
  object_attr.displayName.text.data = local_5a0.text.data;
  UA_NODEID_NUMERIC(&local_154, 1, 0x2e696);
  UA_NODEID_NUMERIC(&local_13c, 1, 0x15f91);
  UA_NODEID_NUMERIC(&local_124, 0, 0x23);
  UA_QUALIFIEDNAME(&local_10c, 1, &DAT_001091d0);
  UA_NODEID_NUMERIC(&local_100, 0, 0x3d);
  uVar39 = 0;
  uVar38 = 0;
  local_698 = local_154.identifier.string.data;
  UStackY_694 = local_154.identifier._8_4_;
  parentNodeId_02.identifierType = local_13c.identifierType;
  parentNodeId_02.namespaceIndex = local_13c.namespaceIndex;
  parentNodeId_02._2_2_ = local_13c._2_2_;
  parentNodeId_02.identifier.numeric = local_13c.identifier.numeric;
  parentNodeId_02.identifier.string.data = local_13c.identifier.string.data;
  parentNodeId_02.identifier._8_4_ = local_13c.identifier._8_4_;
  parentNodeId_02.identifier._12_4_ = local_13c.identifier._12_4_;
  referenceTypeId_04.identifierType = local_124.identifierType;
  referenceTypeId_04.namespaceIndex = local_124.namespaceIndex;
  referenceTypeId_04._2_2_ = local_124._2_2_;
  referenceTypeId_04.identifier.numeric = local_124.identifier.numeric;
  referenceTypeId_04.identifier.string.data = local_124.identifier.string.data;
  referenceTypeId_04.identifier._8_4_ = local_124.identifier._8_4_;
  referenceTypeId_04.identifier._12_4_ = local_124.identifier._12_4_;
  browseName_04.name.length = local_10c.name.length;
  browseName_04.namespaceIndex = local_10c.namespaceIndex;
  browseName_04._2_2_ = local_10c._2_2_;
  browseName_04.name.data = local_10c.name.data;
  typeDefinition_04.identifierType = local_100.identifierType;
  typeDefinition_04.namespaceIndex = local_100.namespaceIndex;
  typeDefinition_04._2_2_ = local_100._2_2_;
  typeDefinition_04.identifier.numeric = local_100.identifier.numeric;
  typeDefinition_04.identifier.string.data = local_100.identifier.string.data;
  typeDefinition_04.identifier._8_4_ = local_100.identifier._8_4_;
  typeDefinition_04.identifier._12_4_ = local_100.identifier._12_4_;
  attr_04.displayName.locale.length = object_attr.displayName.locale.length;
  attr_04.specifiedAttributes = object_attr.specifiedAttributes;
  attr_04.displayName.locale.data = object_attr.displayName.locale.data;
  attr_04.displayName.text.length = object_attr.displayName.text.length;
  attr_04.displayName.text.data = object_attr.displayName.text.data;
  attr_04.description.locale.length = object_attr.description.locale.length;
  attr_04.description.locale.data = object_attr.description.locale.data;
  attr_04.description.text.length = object_attr.description.text.length;
  attr_04.description.text.data = object_attr.description.text.data;
  attr_04.writeMask = object_attr.writeMask;
  attr_04.userWriteMask = object_attr.userWriteMask;
  attr_04.eventNotifier = object_attr.eventNotifier;
  attr_04._45_3_ = object_attr._45_3_;
  uVar9 = local_154.identifier.numeric;
  aVar22 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar9);
  UVar51 = local_154.namespaceIndex;
  uVar61._2_2_ = local_154._2_2_;
  register0x00000028 = local_154.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar22, uVar72);
  UVar26 = object_attr.specifiedAttributes;
  sVar27 = object_attr.displayName.locale.length;
  pUVar28 = object_attr.displayName.locale.data;
  sVar29 = object_attr.displayName.text.length;
  pUVar30 = object_attr.displayName.text.data;
  sVar31 = object_attr.description.locale.length;
  pUVar32 = object_attr.description.locale.data;
  sVar33 = object_attr.description.text.length;
  pUVar34 = object_attr.description.text.data;
  UVar35 = object_attr.writeMask;
  UVar36 = object_attr.userWriteMask;
  uVar37 = object_attr._44_4_;
  UA_Server_addObjectNode(server, UVar14, parentNodeId_02, referenceTypeId_04, browseName_04, typeDefinition_04,
                          attr_04, (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  for (i = 0; i < 0x10; i = i + 1)
  {
    UA_LOCALIZEDTEXT(&local_5a0, "en_US", *(char **)(Obj_folder_MOLDPARATOR + i * 0xc));
    object_attr.description.locale.length = local_5a0.locale.length;
    object_attr.description.locale.data = local_5a0.locale.data;
    object_attr.description.text.length = local_5a0.text.length;
    object_attr.description.text.data = local_5a0.text.data;
    UA_LOCALIZEDTEXT(&local_5a0, "en_US", *(char **)(Obj_folder_MOLDPARATOR + i * 0xc + 4));
    object_attr.displayName.locale.length = local_5a0.locale.length;
    object_attr.displayName.locale.data = local_5a0.locale.data;
    object_attr.displayName.text.length = local_5a0.text.length;
    object_attr.displayName.text.data = local_5a0.text.data;
    UA_NODEID_NUMERIC(&local_e8, 1, *(UA_UInt32 *)(Obj_folder_MOLDPARATOR + i * 0xc + 8));
    UA_NODEID_NUMERIC(&local_d0, 1, 0x2e697);
    UA_NODEID_NUMERIC(&local_b8, 0, 0x23);
    UA_QUALIFIEDNAME(&local_a0, 1, "DepthDemo");
    UA_NODEID_NUMERIC(&local_94, 0, 0x3d);
    uVar39 = 0;
    uVar38 = 0;
    local_698 = local_e8.identifier.string.data;
    UStackY_694 = local_e8.identifier._8_4_;
    parentNodeId_03.identifierType = local_d0.identifierType;
    parentNodeId_03.namespaceIndex = local_d0.namespaceIndex;
    parentNodeId_03._2_2_ = local_d0._2_2_;
    parentNodeId_03.identifier.numeric = local_d0.identifier.numeric;
    parentNodeId_03.identifier.string.data = local_d0.identifier.string.data;
    parentNodeId_03.identifier._8_4_ = local_d0.identifier._8_4_;
    parentNodeId_03.identifier._12_4_ = local_d0.identifier._12_4_;
    referenceTypeId_05.identifierType = local_b8.identifierType;
    referenceTypeId_05.namespaceIndex = local_b8.namespaceIndex;
    referenceTypeId_05._2_2_ = local_b8._2_2_;
    referenceTypeId_05.identifier.numeric = local_b8.identifier.numeric;
    referenceTypeId_05.identifier.string.data = local_b8.identifier.string.data;
    referenceTypeId_05.identifier._8_4_ = local_b8.identifier._8_4_;
    referenceTypeId_05.identifier._12_4_ = local_b8.identifier._12_4_;
    browseName_05.name.length = local_a0.name.length;
    browseName_05.namespaceIndex = local_a0.namespaceIndex;
    browseName_05._2_2_ = local_a0._2_2_;
    browseName_05.name.data = local_a0.name.data;
    typeDefinition_05.identifierType = local_94.identifierType;
    typeDefinition_05.namespaceIndex = local_94.namespaceIndex;
    typeDefinition_05._2_2_ = local_94._2_2_;
    typeDefinition_05.identifier.numeric = local_94.identifier.numeric;
    typeDefinition_05.identifier.string.data = local_94.identifier.string.data;
    typeDefinition_05.identifier._8_4_ = local_94.identifier._8_4_;
    typeDefinition_05.identifier._12_4_ = local_94.identifier._12_4_;
    attr_05.displayName.locale.length = object_attr.displayName.locale.length;
    attr_05.specifiedAttributes = object_attr.specifiedAttributes;
    attr_05.displayName.locale.data = object_attr.displayName.locale.data;
    attr_05.displayName.text.length = object_attr.displayName.text.length;
    attr_05.displayName.text.data = object_attr.displayName.text.data;
    attr_05.description.locale.length = object_attr.description.locale.length;
    attr_05.description.locale.data = object_attr.description.locale.data;
    attr_05.description.text.length = object_attr.description.text.length;
    attr_05.description.text.data = object_attr.description.text.data;
    attr_05.writeMask = object_attr.writeMask;
    attr_05.userWriteMask = object_attr.userWriteMask;
    attr_05.eventNotifier = object_attr.eventNotifier;
    attr_05._45_3_ = object_attr._45_3_;
    uVar10 = local_e8.identifier.numeric;
    aVar23 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar10);
    UVar52 = local_e8.namespaceIndex;
    uVar62._2_2_ = local_e8._2_2_;
    register0x00000028 = local_e8.identifierType;
    UVar14 = (UA_NodeId)CONCAT168(aVar23, uVar73);
    UVar26 = object_attr.specifiedAttributes;
    sVar27 = object_attr.displayName.locale.length;
    pUVar28 = object_attr.displayName.locale.data;
    sVar29 = object_attr.displayName.text.length;
    pUVar30 = object_attr.displayName.text.data;
    sVar31 = object_attr.description.locale.length;
    pUVar32 = object_attr.description.locale.data;
    sVar33 = object_attr.description.text.length;
    pUVar34 = object_attr.description.text.data;
    UVar35 = object_attr.writeMask;
    UVar36 = object_attr.userWriteMask;
    uVar37 = object_attr._44_4_;
    UA_Server_addObjectNode(server, UVar14, parentNodeId_03, referenceTypeId_05, browseName_05, typeDefinition_05,
                            attr_05, (UA_InstantiationCallback *)0x0, (UA_NodeId *)0x0);
  }
  id = 51000;
  for (type = 0; type < 0x1fe; type = type + 1)
  {
    UA_VariableAttributes_init(&attr1);
    attr1.valueRank = -2;
    attr1.accessLevel = '\x03';
    UA_LOCALIZEDTEXT(&local_5a0, "en_US", *(char **)(&DAT_001594f0 + type * 0x40));
    attr1.description.locale.length = local_5a0.locale.length;
    attr1.description.locale.data = local_5a0.locale.data;
    attr1.description.text.length = local_5a0.text.length;
    attr1.description.text.data = local_5a0.text.data;
    UA_LOCALIZEDTEXT_ALLOC(&local_5a0, "en_US", *(char **)(&DAT_001594ec + type * 0x40));
    attr1.displayName.locale.length = local_5a0.locale.length;
    attr1.displayName.locale.data = local_5a0.locale.data;
    attr1.displayName.text.length = local_5a0.text.length;
    attr1.displayName.text.data = local_5a0.text.data;
    g_index_1 = type;
    UA_QUALIFIEDNAME(&dateName, 1, *(char **)(&DAT_001594ec + type * 0x40));
    UA_NODEID_NUMERIC(&local_7c, 1, *(int *)(&DAT_001594e8 + type * 0x40) + 0x1e240);
    UA_NODEID_NUMERIC(&local_64, 1, *(UA_UInt32 *)(&DAT_001594fc + type * 0x40));
    UA_NODEID_NUMERIC(&local_4c, 0, 0x23);
    outNewNodeId = &dataSourceId;
    uVar41 = 0;
    pcVar42 = readTimeData;
    p_Var43 = (_func_UA_StatusCode_void_ptr_UA_NodeId_UA_Variant_ptr_UA_NumericRange_ptr *)0x0;
    index = type;
    memcpy(&stack0xfffff9c8, &attr1, 0x80);
    local_698 = local_7c.identifier.string.data;
    UStackY_694 = local_7c.identifier._8_4_;
    parentNodeId_04.identifierType = local_64.identifierType;
    parentNodeId_04.namespaceIndex = local_64.namespaceIndex;
    parentNodeId_04._2_2_ = local_64._2_2_;
    parentNodeId_04.identifier.numeric = local_64.identifier.numeric;
    parentNodeId_04.identifier.string.data = local_64.identifier.string.data;
    parentNodeId_04.identifier._8_4_ = local_64.identifier._8_4_;
    parentNodeId_04.identifier._12_4_ = local_64.identifier._12_4_;
    referenceTypeId_06.identifierType = local_4c.identifierType;
    referenceTypeId_06.namespaceIndex = local_4c.namespaceIndex;
    referenceTypeId_06._2_2_ = local_4c._2_2_;
    referenceTypeId_06.identifier.numeric = local_4c.identifier.numeric;
    referenceTypeId_06.identifier.string.data = local_4c.identifier.string.data;
    referenceTypeId_06.identifier._8_4_ = local_4c.identifier._8_4_;
    referenceTypeId_06.identifier._12_4_ = local_4c.identifier._12_4_;
    browseName_06.name.length = dateName.name.length;
    browseName_06.namespaceIndex = dateName.namespaceIndex;
    browseName_06._2_2_ = dateName._2_2_;
    browseName_06.name.data = dateName.name.data;
    typeDefinition_06.identifierType = UA_NODEID_NULL.identifierType;
    typeDefinition_06.namespaceIndex = UA_NODEID_NULL.namespaceIndex;
    typeDefinition_06._2_2_ = UA_NODEID_NULL._2_2_;
    typeDefinition_06.identifier.numeric = UA_NODEID_NULL.identifier.numeric;
    typeDefinition_06.identifier.string.data = UA_NODEID_NULL.identifier.string.data;
    typeDefinition_06.identifier._8_4_ = UA_NODEID_NULL.identifier._8_4_;
    typeDefinition_06.identifier._12_4_ = UA_NODEID_NULL.identifier._12_4_;
    attr_06.displayName.locale.length = sVar27;
    attr_06.specifiedAttributes = UVar26;
    attr_06.displayName.locale.data = pUVar28;
    attr_06.displayName.text.length = sVar29;
    attr_06.displayName.text.data = pUVar30;
    attr_06.description.locale.length = sVar31;
    attr_06.description.locale.data = pUVar32;
    attr_06.description.text.length = sVar33;
    attr_06.description.text.data = pUVar34;
    attr_06.writeMask = UVar35;
    attr_06.userWriteMask = UVar36;
    attr_06.value.type = (UA_DataType *)uVar37;
    attr_06.value.storageType = uVar38;
    attr_06.value.arrayLength = uVar39;
    auVar40 = in_stack_fffffa00._12_24_;
    attr_06.value.data = (void *)in_stack_fffffa00._0_4_;
    attr_06.value.arrayDimensionsSize = in_stack_fffffa00._4_4_;
    attr_06.value.arrayDimensions = (UA_UInt32 *)in_stack_fffffa00._8_4_;
    attr_06.dataType.namespaceIndex = auVar40._0_2_;
    attr_06.dataType._2_2_ = auVar40._2_2_;
    attr_06.dataType.identifierType = auVar40._4_4_;
    attr_06.dataType.identifier = (anon_union_16_4_621dfe33_for_identifier)auVar40._8_16_;
    attr_06.valueRank = in_stack_fffffa00._36_4_;
    attr_06.arrayDimensionsSize = in_stack_fffffa00._40_4_;
    attr_06.arrayDimensions = (UA_UInt32 *)in_stack_fffffa00._44_4_;
    attr_06.accessLevel = in_stack_fffffa00[0x30];
    attr_06.userAccessLevel = in_stack_fffffa00[0x31];
    attr_06._106_6_ = in_stack_fffffa00._50_6_;
    attr_06.minimumSamplingInterval = (UA_Double)in_stack_fffffa00._56_8_;
    attr_06.historizing = (UA_Boolean)in_stack_fffffa00[0x40];
    attr_06._121_7_ = in_stack_fffffa00._65_7_;
    dataSource.read = pcVar42;
    dataSource.handle = (void *)uVar41;
    dataSource.write = p_Var43;
    uVar11 = local_7c.identifier.numeric;
    aVar24 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar11);
    UVar53 = local_7c.namespaceIndex;
    uVar63._2_2_ = local_7c._2_2_;
    register0x00000028 = local_7c.identifierType;
    UVar14 = (UA_NodeId)CONCAT168(aVar24, uVar74);
    UA_Server_addDataSourceVariableNode(server, UVar14, parentNodeId_04, referenceTypeId_06, browseName_06, typeDefinition_06,
                                        attr_06, dataSource, outNewNodeId, index);
    UA_LocalizedText_deleteMembers(&attr1.displayName);
    usleep(0x46);
  }
  UA_LOCALIZEDTEXT(&objectsName, "en_US", "Objects");
  UA_NODEID_NUMERIC(&local_34, 0, 0x55);
  local_698 = local_34.identifier.string.data;
  UStackY_694 = local_34.identifier._8_4_;
  displayName.locale.data = objectsName.locale.data;
  displayName.locale.length = objectsName.locale.length;
  displayName.text.length = objectsName.text.length;
  displayName.text.data = objectsName.text.data;
  uVar12 = local_34.identifier.numeric;
  aVar25 = (anon_union_16_4_621dfe33_for_identifier)CONCAT124(UVar13.identifier._4_12_, uVar12);
  UVar54 = local_34.namespaceIndex;
  uVar64._2_2_ = local_34._2_2_;
  register0x00000028 = local_34.identifierType;
  UVar14 = (UA_NodeId)CONCAT168(aVar25, uVar75);
  UA_Server_writeDisplayName(server, UVar14, displayName);
  retval = UA_Server_run(server, &running);
  UA_ByteString_deleteMembers(&config.serverCertificate);
  UA_Server_delete(server);
  (*nl.deleteMembers)(&nl);
  return retval;
}

void CreateCRC32Table(void)

{
  uint j;
  uint i;
  uint nTemp;

  for (i = 0; i < 0x100; i = i + 1)
  {
    nTemp = i;
    for (j = 0; j < 8; j = j + 1)
    {
      if ((nTemp & 1) == 0)
      {
        nTemp = nTemp >> 1;
      }
      else
      {
        nTemp = nTemp >> 1 ^ 0xedb88320;
      }
    }
    _CRC32_Talbe[i] = nTemp;
  }
  return;
}

uint GetCRC32B(uint CRCCode, char *pData, uint Length)

{
  uint Length_local;
  char *pData_local;
  uint CRCCode_local;
  uint nResult;
  uint i;

  nResult = CRCCode;
  for (i = 0; i < Length; i = i + 1)
  {
    nResult = nResult >> 8 ^ _CRC32_Talbe[(nResult ^ (byte)pData[i]) & 0xff];
  }
  return nResult;
}

uint GetCRC32(char *pData, uint Length)

{
  uint uVar1;
  uint Length_local;
  char *pData_local;

  uVar1 = GetCRC32B(0xffffffff, pData, Length);
  return uVar1;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

int DestroyTimer(void)

{
  return 0;
}

void AddDnCounter(long *plCounter)

{
  long **pplVar1;
  long *plCounter_local;

  if (u_nDnCounter < 0x40)
  {
    pplVar1 = u_plDnCounter + u_nDnCounter;
    u_nDnCounter = u_nDnCounter + 1;
    *pplVar1 = plCounter;
  }
  return;
}

void DeleteDnCounter(long *plCounter)

{
  long *plCounter_local;
  int j;
  int i;

  i = 0;
  while (true)
  {
    if (u_nDnCounter <= i)
    {
      return;
    }
    if (u_plDnCounter[i] == plCounter)
      break;
    i = i + 1;
  }
  u_nDnCounter = u_nDnCounter + -1;
  for (j = i; j < u_nDnCounter; j = j + 1)
  {
    u_plDnCounter[j] = u_plDnCounter[j + 1];
  }
  return;
}

void AddUpCounter(long *plCounter)

{
  long **pplVar1;
  long *plCounter_local;

  if (u_nUpCounter < 0x40)
  {
    pplVar1 = u_plUpCounter + u_nUpCounter;
    u_nUpCounter = u_nUpCounter + 1;
    *pplVar1 = plCounter;
  }
  return;
}

void DeleteUpCounter(long *plCounter)

{
  long *plCounter_local;
  int j;
  int i;

  i = 0;
  while (true)
  {
    if (u_nUpCounter <= i)
    {
      return;
    }
    if (u_plUpCounter[i] == plCounter)
      break;
    i = i + 1;
  }
  u_nUpCounter = u_nUpCounter + -1;
  for (j = i; j < u_nUpCounter; j = j + 1)
  {
    u_plUpCounter[j] = u_plUpCounter[j + 1];
  }
  return;
}

void RunTimer(void)

{
  int i;

  for (i = 0; i < u_nDnCounter; i = i + 1)
  {
    *u_plDnCounter[i] = *u_plDnCounter[i] + -1;
  }
  for (i = 0; i < u_nUpCounter; i = i + 1)
  {
    *u_plUpCounter[i] = *u_plUpCounter[i] + 1;
  }
  return;
}

void background(void)

{
  char mac_address[20];

  DBdata = (ushort)(-1 < g_send_to_hmi_offline);
  memset(mac_address, 0, 0x14);
  sprintf(mac_address, "%02X-%02X-%02X-%02X-%02X-%02X", (uint)(byte)g_opc_ua_mac[0],
          (uint)(byte)g_opc_ua_mac[1], (uint)(byte)g_opc_ua_mac[2], (uint)(byte)g_opc_ua_mac[3],
          (uint)(byte)g_opc_ua_mac[4], (uint)(byte)g_opc_ua_mac[5]);
  DAT_00159540._0_1_ = mac_address[0];
  DAT_00159540._1_1_ = mac_address[1];
  DAT_00159540._2_1_ = mac_address[2];
  DAT_00159540._3_1_ = mac_address[3];
  DAT_00159544._0_1_ = mac_address[4];
  DAT_00159544._1_1_ = mac_address[5];
  DAT_00159544._2_1_ = mac_address[6];
  DAT_00159544._3_1_ = mac_address[7];
  DAT_00159548._0_1_ = mac_address[8];
  DAT_00159548._1_1_ = mac_address[9];
  DAT_00159548._2_1_ = mac_address[10];
  DAT_00159548._3_1_ = mac_address[0xb];
  DAT_0015954c._0_1_ = mac_address[0xc];
  DAT_0015954c._1_1_ = mac_address[0xd];
  DAT_0015954c._2_1_ = mac_address[0xe];
  DAT_0015954c._3_1_ = mac_address[0xf];
  DAT_00159550._0_1_ = mac_address[0x10];
  DAT_00159550._1_1_ = mac_address[0x11];
  DAT_00159550._2_1_ = mac_address[0x12];
  DAT_00159550._3_1_ = mac_address[0x13];
  DAT_00159580._0_1_ = g_opc_ua_server_ip[0];
  DAT_00159580._1_1_ = g_opc_ua_server_ip[1];
  DAT_00159580._2_1_ = g_opc_ua_server_ip[2];
  DAT_00159580._3_1_ = g_opc_ua_server_ip[3];
  DAT_00159584._0_1_ = g_opc_ua_server_ip[4];
  DAT_00159584._1_1_ = g_opc_ua_server_ip[5];
  DAT_00159584._2_1_ = g_opc_ua_server_ip[6];
  DAT_00159584._3_1_ = g_opc_ua_server_ip[7];
  DAT_00159588._0_1_ = g_opc_ua_server_ip[8];
  DAT_00159588._1_1_ = g_opc_ua_server_ip[9];
  DAT_00159588._2_1_ = g_opc_ua_server_ip[10];
  DAT_00159588._3_1_ = g_opc_ua_server_ip[0xb];
  DAT_0015958c._0_1_ = g_opc_ua_server_ip[0xc];
  DAT_0015958c._1_1_ = g_opc_ua_server_ip[0xd];
  DAT_0015958c._2_1_ = g_opc_ua_server_ip[0xe];
  DAT_0015958c._3_1_ = g_opc_ua_server_ip[0xf];
  DAT_00159500 = (uint16_t)g_vendor_value;
  return;
}

void *Timer_Run(void *data)

{
  pthread_t __th;
  int iVar1;
  void *data_local;

  __th = pthread_self();
  pthread_detach(__th);
  iVar1 = pthread_setcanceltype(1, (int *)0x0);
  if (iVar1 != 0)
  {
    perror("TimerRun");
    return (void *)0x0;
  }
  do
  {
    RunTimer();
    usleep(1000);
    background();
  } while (true);
}

int InitTimer(void)

{
  int param1;
  int rc;

  param1 = pthread_create(&m_threadTimer, (pthread_attr_t *)0x0, Timer_Run, (void *)0x0);
  if (param1 == 0)
  {
    puts("Timer Thread create successful!");
  }
  else
  {
    printf("Timer pthread_create(), return value: %d\n", param1);
  }
  return 0;
}

uint16_t Data2Str(uint8_t *pData, char *buf, uint16_t u16DataLen)

{
  byte bVar1;
  byte bVar2;
  uint16_t u16DataLen_local;
  char *buf_local;
  uint8_t *pData_local;
  uint8_t u8LValue;
  uint8_t u8HValue;
  char temp;
  uint16_t u16Res;
  int i;

  u16Res = 0;
  for (i = 0; i < (int)(uint)u16DataLen; i = i + 1)
  {
    if (pData[i] < 0x10)
    {
      buf[i * 2] = '0';
      if (pData[i] < 10)
      {
        buf[i * 2 + 1] = pData[i] + '0';
      }
      else
      {
        buf[i * 2 + 1] = pData[i] + '7';
      }
    }
    else
    {
      bVar1 = pData[i] >> 4;
      bVar2 = pData[i] & 0xf;
      if (bVar1 < 10)
      {
        buf[i * 2] = bVar1 + 0x30;
      }
      else
      {
        buf[i * 2] = bVar1 + 0x37;
      }
      if (bVar2 < 10)
      {
        buf[i * 2 + 1] = bVar2 + 0x30;
      }
      else
      {
        buf[i * 2 + 1] = bVar2 + 0x37;
      }
    }
    u16Res = u16Res + 2;
  }
  buf[u16Res] = '\0';
  return u16Res;
}

uint16_t Str2Data(char *buf, uint8_t *pData, uint16_t u16BufLen)

{
  uint16_t u16BufLen_local;
  uint8_t *pData_local;
  char *buf_local;
  uint8_t u8LValue;
  uint8_t u8HValue;
  int i;

  for (i = 0; i < (int)(uint)(u16BufLen >> 1); i = i + 1)
  {
    if ((byte)buf[i * 2] < 0x41)
    {
      u8HValue = buf[i * 2] + 0xd0;
    }
    else
    {
      u8HValue = buf[i * 2] + 0xc9;
    }
    if ((byte)buf[i * 2 + 1] < 0x41)
    {
      u8LValue = buf[i * 2 + 1] + 0xd0;
    }
    else
    {
      u8LValue = buf[i * 2 + 1] + 0xc9;
    }
    pData[i] = u8HValue << 4 | u8LValue;
  }
  return u16BufLen >> 1;
}

_Bool logInit(char *domain)

{
  char *domain_local;

  if (domain != (char *)0x0)
  {
    logger.domain = domain;
    logSetFlags(0x1f2);
  }
  return domain != (char *)0x0;
}

char *currentTimeString(void)

{
  time_t rawtime;
  tm *timeinfo;
  char *buffer;

  buffer = malloc(0x51);
  time(&rawtime);
  timeinfo = (tm *)localtime(&rawtime);
  strftime(buffer, 0x50, "%c", (tm *)timeinfo);
  return buffer;
}

ulong parseBlackList(char *fileName)

{
  int iVar1;
  int iVar2;
  uint32_t uVar3;
  uint64_t uVar4;
  longlong lVar5;
  char *fileName_local;
  char newprop[10];
  xmlChar *tmpProp;
  xmlDocPtr doc;
  int i;
  ulong long_val;
  xmlNodePtr currNode;
  ulong retval;

  // Unresolved local var: xmlChar * tmpNodeText@[???]
  uVar4 = xmlParseFile(fileName);
  uVar3 = (uint32_t)((ulonglong)uVar4 >> 0x20);
  iVar1 = (int)uVar4;
  if (iVar1 == 0)
  {
    retval = 1;
  }
  else
  {
    uVar4 = xmlDocGetRootElement(iVar1);
    uVar3 = (uint32_t)((ulonglong)uVar4 >> 0x20);
    iVar2 = (int)uVar4;
    if (iVar2 == 0)
    {
      retval = 2;
    }
    else
    {
      uVar4 = xmlStrcmp(*(uint32_t *)(iVar2 + 8), "iNetData");
      uVar3 = (uint32_t)((ulonglong)uVar4 >> 0x20);
      if ((int)uVar4 == 0)
      {
        currNode = *(xmlNodePtr *)(iVar2 + 0xc);
        for (i = 0; i < 3; i = i + 1)
        {
          uVar4 = xmlStrcmp(currNode->name, "iNetData");
          lVar5 = CONCAT44((int)((ulonglong)uVar4 >> 0x20), long_val);
          if ((int)uVar4 == 0)
          {
            uVar4 = xmlGetProp(currNode, "version");
            iVar2 = (int)uVar4;
            lVar5 = CONCAT44((int)((ulonglong)uVar4 >> 0x20), long_val);
            if (iVar2 != 0)
            {
              newprop._0_4_ = *(uint32_t *)(iVar2 + 2);
              newprop._4_4_ = *(uint32_t *)(iVar2 + 6);
              newprop._8_2_ = *(uint16_t *)(iVar2 + 10);
              lVar5 = atoll(newprop);
            }
          }
          uVar3 = (uint32_t)((ulonglong)lVar5 >> 0x20);
          long_val = (ulong)lVar5;
          currNode = currNode->next;
        }
        retval = long_val;
      }
      else
      {
        retval = 3;
      }
    }
  }
  if (iVar1 != 0)
  {
    xmlFreeDoc(iVar1, uVar3);
  }
  return retval;
}

xmlXPathObjectPtr getNodeset(xmlDocPtr pdoc, xmlChar *xpath)

{
  int iVar1;
  xmlChar *xpath_local;
  xmlDocPtr pdoc_local;
  xmlXPathContextPtr context;
  xmlXPathObjectPtr result;

  result = (xmlXPathObjectPtr)0x0;
  iVar1 = xmlXPathNewContext(pdoc);
  if (pdoc == (xmlDocPtr)0x0)
  {
    puts("pdoc is NULL");
    result = (xmlXPathObjectPtr)0x0;
  }
  else if (xpath != (xmlChar *)0x0)
  {
    if (iVar1 == 0)
    {
      puts("context is NULL");
      result = (xmlXPathObjectPtr)0x0;
    }
    else
    {
      result = (xmlXPathObjectPtr)xmlXPathEvalExpression(xpath, iVar1);
      xmlXPathFreeContext(iVar1);
      if (result == (xmlXPathObjectPtr)0x0)
      {
        puts("xmlXPathEvalExpression return NULL");
        result = (xmlXPathObjectPtr)0x0;
      }
      else if (((result->nodesetval == (xmlNodeSetPtr)0x0) || (result->nodesetval->nodeNr == 0)) ||
               (result->nodesetval->nodeTab == (xmlNodePtr *)0x0))
      {
        xmlXPathFreeObject(result);
        puts("nodeset is empty");
        result = (xmlXPathObjectPtr)0x0;
      }
    }
  }
  return result;
}

int parseMoldData_54_52_xml(char *file_name)

{
  xmlDocPtr pdoc_00;
  int iVar1;
  xmlXPathObjectPtr pxVar2;
  size_t sVar3;
  xmlNodeSetPtr pxVar4;
  xmlChar *pxVar5;
  xmlChar *pxVar6;
  char *file_name_local;
  xmlNodeSetPtr nodeset;
  xmlXPathObjectPtr result;
  xmlChar *xpath;
  xmlNodePtr proot;
  xmlDocPtr pdoc;
  int i_1;
  int i;
  xmlNodePtr cur;
  int Mold_Data_Count;

  if (file_name == (char *)0x0)
  {
    // WARNING: Subroutine does not return
    __assert_fail("file_name", "myxml.c", 0x96, "parseMoldData_54_52_xml");
  }
  Mold_Data_Count = 0;
  xmlKeepBlanksDefault(0);
  pdoc_00 = (xmlDocPtr)xmlReadFile(file_name, "UTF-8", 1);
  if (pdoc_00 == (xmlDocPtr)0x0)
  {
    puts("error:can\'t open file!");
    xmlFreeDoc(0);
    xmlCleanupParser();
    xmlMemoryDump();
    Mold_Data_Count = -1;
  }
  else
  {
    iVar1 = xmlDocGetRootElement(pdoc_00);
    if (iVar1 == 0)
    {
      puts("error: file is empty!");
      xmlFreeDoc(pdoc_00);
      xmlCleanupParser();
      xmlMemoryDump();
      Mold_Data_Count = -1;
    }
    else
    {
      pxVar2 = getNodeset(pdoc_00, (xmlChar *)"//iNetData");
      if (pxVar2 == (xmlXPathObjectPtr)0x0)
      {
        puts("result is NULL");
        xmlFreeDoc(pdoc_00);
        xmlCleanupParser();
        xmlMemoryDump();
        Mold_Data_Count = -1;
      }
      else
      {
        if (pxVar2 != (xmlXPathObjectPtr)0x0)
        {
          pxVar4 = pxVar2->nodesetval;
          if (pxVar4->nodeNr < 1)
          {
            puts("error: nodeNr is empty!");
            xmlFreeDoc(pdoc_00);
            xmlCleanupParser();
            xmlMemoryDump();
            return -1;
          }
          if (pxVar4->nodeNr + -1 < 0x3e9)
          {
            Mold_Data_Count = pxVar4->nodeNr + -1;
          }
          else
          {
            Mold_Data_Count = 1000;
          }
          logDebug("Mold_Data_Count: %d\n", Mold_Data_Count);
          for (cur = (*pxVar4->nodeTab)->children; cur != (xmlNodePtr)0x0; cur = cur->next)
          {
            iVar1 = xmlStrcmp(cur->name, "Version");
            if (iVar1 == 0)
            {
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar5 = (xmlChar *)0x0;
              }
              else
              {
                pxVar5 = cur->children->content;
              }
              logDebug("Version: %s\n", pxVar5);
              memset(CurrentMoldCfgFileVer, 0, 0x1e);
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar5 = (xmlChar *)0x0;
              }
              else
              {
                pxVar5 = cur->children->content;
              }
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar6 = (xmlChar *)0x0;
              }
              else
              {
                pxVar6 = cur->children->content;
              }
              sVar3 = strlen((char *)pxVar6);
              memcpy(CurrentMoldCfgFileVer, pxVar5, sVar3);
            }
            iVar1 = xmlStrcmp(cur->name, "DataTime");
            if (iVar1 == 0)
            {
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar5 = (xmlChar *)0x0;
              }
              else
              {
                pxVar5 = cur->children->content;
              }
              logDebug("DataTime: %s\n", pxVar5);
              memset(CurrentMoldCfgFileDataTime, 0, 0x1e);
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar5 = (xmlChar *)0x0;
              }
              else
              {
                pxVar5 = cur->children->content;
              }
              if (cur->children->type == XML_ELEMENT_NODE)
              {
                pxVar6 = (xmlChar *)0x0;
              }
              else
              {
                pxVar6 = cur->children->content;
              }
              sVar3 = strlen((char *)pxVar6);
              memcpy(CurrentMoldCfgFileDataTime, pxVar5, sVar3);
              break;
            }
          }
          for (i = 0; i < Mold_Data_Count; i = i + 1)
          {
            for (cur = pxVar4->nodeTab[i + 1]->children; cur != (xmlNodePtr)0x0; cur = cur->next)
            {
              iVar1 = xmlStrcmp(cur->name, &DAT_0010fbbc);
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                logDebug("Name: %s\n", pxVar5);
                memset(DBdata_54_52 + i, 0, 0x20);
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                sVar3 = strlen((char *)pxVar6);
                memcpy(DBdata_54_52 + i, pxVar5, sVar3);
                memset(DBdata_54_52_B_spec + i, 0, 0x20);
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                sVar3 = strlen((char *)pxVar6);
                memcpy(DBdata_54_52_B_spec + i, pxVar5, sVar3);
              }
              iVar1 = xmlStrcmp(cur->name, "MoldSetAddress54");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("MoldSetAddress54: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52[i].Address54 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                DBdata_54_52[i].Address54 = iVar1;
              }
              iVar1 = xmlStrcmp(cur->name, "UpdateAddress54");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("UpdateAddress54: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52_B_spec[i].Address54 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                DBdata_54_52_B_spec[i].Address54 = iVar1;
              }
              iVar1 = xmlStrcmp(cur->name, "MoldSetPrecision54");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("MoldSetPrecision54: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52[i].Precision54 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                if (-1 < iVar1)
                {
                  if (cur->children->type == XML_ELEMENT_NODE)
                  {
                    pxVar5 = (xmlChar *)0x0;
                  }
                  else
                  {
                    pxVar5 = cur->children->content;
                  }
                  iVar1 = atoi((char *)pxVar5);
                  if (iVar1 < 0x80)
                  {
                    if (cur->children->type == XML_ELEMENT_NODE)
                    {
                      pxVar5 = (xmlChar *)0x0;
                    }
                    else
                    {
                      pxVar5 = cur->children->content;
                    }
                    iVar1 = atoi((char *)pxVar5);
                    DBdata_54_52[i].Precision54 = (char)iVar1;
                    goto LAB_00019954;
                  }
                }
                DBdata_54_52[i].Precision54 = -1;
              }
            LAB_00019954:
              iVar1 = xmlStrcmp(cur->name, "UpdatePrecision54");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("UpdatePrecision54: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52_B_spec[i].Precision54 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                if (-1 < iVar1)
                {
                  if (cur->children->type == XML_ELEMENT_NODE)
                  {
                    pxVar5 = (xmlChar *)0x0;
                  }
                  else
                  {
                    pxVar5 = cur->children->content;
                  }
                  iVar1 = atoi((char *)pxVar5);
                  if (iVar1 < 0x80)
                  {
                    if (cur->children->type == XML_ELEMENT_NODE)
                    {
                      pxVar5 = (xmlChar *)0x0;
                    }
                    else
                    {
                      pxVar5 = cur->children->content;
                    }
                    iVar1 = atoi((char *)pxVar5);
                    DBdata_54_52_B_spec[i].Precision54 = (char)iVar1;
                    goto LAB_00019b08;
                  }
                }
                DBdata_54_52_B_spec[i].Precision54 = -1;
              }
            LAB_00019b08:
              iVar1 = xmlStrcmp(cur->name, "MoldSetAddress52");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("MoldSetAddress52: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52[i].Address52 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                DBdata_54_52[i].Address52 = iVar1;
              }
              iVar1 = xmlStrcmp(cur->name, "UpdateAddress52");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("UpdateAddress52: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52_B_spec[i].Address52 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                DBdata_54_52_B_spec[i].Address52 = iVar1;
              }
              iVar1 = xmlStrcmp(cur->name, "MoldSetPrecision52");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("MoldSetPrecision52: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52[i].Precision52 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                if (-1 < iVar1)
                {
                  if (cur->children->type == XML_ELEMENT_NODE)
                  {
                    pxVar5 = (xmlChar *)0x0;
                  }
                  else
                  {
                    pxVar5 = cur->children->content;
                  }
                  iVar1 = atoi((char *)pxVar5);
                  if (iVar1 < 0x80)
                  {
                    if (cur->children->type == XML_ELEMENT_NODE)
                    {
                      pxVar5 = (xmlChar *)0x0;
                    }
                    else
                    {
                      pxVar5 = cur->children->content;
                    }
                    iVar1 = atoi((char *)pxVar5);
                    DBdata_54_52[i].Precision52 = (char)iVar1;
                    goto LAB_00019ecc;
                  }
                }
                DBdata_54_52[i].Precision52 = -1;
              }
            LAB_00019ecc:
              iVar1 = xmlStrcmp(cur->name, "UpdatePrecision52");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar6);
                logDebug("Precision52: %s,%d\n", pxVar5, iVar1);
                DBdata_54_52_B_spec[i].Precision52 = -1;
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                iVar1 = atoi((char *)pxVar5);
                if (-1 < iVar1)
                {
                  if (cur->children->type == XML_ELEMENT_NODE)
                  {
                    pxVar5 = (xmlChar *)0x0;
                  }
                  else
                  {
                    pxVar5 = cur->children->content;
                  }
                  iVar1 = atoi((char *)pxVar5);
                  if (iVar1 < 0x80)
                  {
                    if (cur->children->type == XML_ELEMENT_NODE)
                    {
                      pxVar5 = (xmlChar *)0x0;
                    }
                    else
                    {
                      pxVar5 = cur->children->content;
                    }
                    iVar1 = atoi((char *)pxVar5);
                    DBdata_54_52_B_spec[i].Precision52 = (char)iVar1;
                    goto LAB_0001a080;
                  }
                }
                DBdata_54_52_B_spec[i].Precision52 = -1;
              }
            LAB_0001a080:
              iVar1 = xmlStrcmp(cur->name, "DescriptionC");
              if (iVar1 == 0)
              {
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                logDebug("DescriptionC: %s\n", pxVar5);
                memset(DBdata_54_52[i].DescriptionC, 0, 0x20);
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                sVar3 = strlen((char *)pxVar6);
                memcpy(DBdata_54_52[i].DescriptionC, pxVar5, sVar3);
                memset(DBdata_54_52_B_spec[i].DescriptionC, 0, 0x20);
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar5 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar5 = cur->children->content;
                }
                if (cur->children->type == XML_ELEMENT_NODE)
                {
                  pxVar6 = (xmlChar *)0x0;
                }
                else
                {
                  pxVar6 = cur->children->content;
                }
                sVar3 = strlen((char *)pxVar6);
                memcpy(DBdata_54_52_B_spec[i].DescriptionC, pxVar5, sVar3);
                break;
              }
            }
          }
          xmlXPathFreeObject(pxVar2);
        }
        logDebug("#########################\n");
        for (i_1 = 0; i_1 < Mold_Data_Count; i_1 = i_1 + 1)
        {
          logDebug("DBdata_54_52[%d]: %s,%d,%d,%d,%d,%s\n", i_1, DBdata_54_52 + i_1,
                   DBdata_54_52[i_1].Address54, (uint)(byte)DBdata_54_52[i_1].Precision54,
                   DBdata_54_52[i_1].Address52, (uint)(byte)DBdata_54_52[i_1].Precision52,
                   i_1 * 0x50 + 0x16146d);
          logDebug("DBdata_54_52_B_spec[%d]: %s,%d,%d,%d,%d,%s\n", i_1, DBdata_54_52_B_spec + i_1,
                   DBdata_54_52_B_spec[i_1].Address54,
                   (uint)(byte)DBdata_54_52_B_spec[i_1].Precision54,
                   DBdata_54_52_B_spec[i_1].Address52,
                   (uint)(byte)DBdata_54_52_B_spec[i_1].Precision52, i_1 * 0x50 + 0x174ced);
        }
        logDebug("#########################\n");
        xmlFreeDoc(pdoc_00);
        xmlCleanupParser();
        xmlMemoryDump();
      }
    }
  }
  return Mold_Data_Count;
}

Signmes *test_RSA_sign(Signmes *__return_storage_ptr__, char *data, int ptf_en_length)

{
  size_t __size;
  int ptf_en_length_local;
  char *data_local;
  uchar md[32];
  Signmes signmes;
  int nOutLen;
  size_t size;
  char *test;
  uchar *sig;
  int nRet;
  RSA *privKey;

  // Unresolved local var: char * signature@[???]
  // Unresolved local var: uchar * buf@[???]
  privKey = (RSA *)0x0;
  nRet = 0;
  SHA256((uchar *)data, ptf_en_length, md);
  privKey = ReadPrivateKey("privkey_2049.pem");
  __size = RSA_size(privKey);
  sig = malloc(__size);
  if (sig == (uchar *)0x0)
  {
    RSA_free(privKey);
  }
  nRet = RSA_sign(0x2a0, md, 0x20, sig, (uint *)&nOutLen, privKey);
  if (nRet != 1)
  {
    RSA_free(privKey);
  }
  test = b64_encode(sig, nOutLen);
  strcpy(signmes.signature, test);
  size = 0x158;
  free(sig);
  RSA_free(privKey);
  signmes.size = size;
  memcpy(__return_storage_ptr__, &signmes, 0x15c);
  return __return_storage_ptr__;
}

char *my_decrypt(char *msg_buff, char *path_key, int oldmessage_len)

{
  FILE *fp;
  RSA *r;
  int flen;
  size_t __n;
  uchar *to;
  int oldmessage_len_local;
  char *path_key_local;
  char *msg_buff_local;
  char outstr2[2000];
  int mun;
  uchar *decryptMsg;
  int rsa_len;
  char *techbuff;
  FILE *file;
  RSA *p_rsa;
  char *p_de;

  memset(outstr2, 0, 2000);
  fp = fopen(path_key, "r");
  if (fp == (FILE *)0x0)
  {
    perror("fopen() error");
    to = (uchar *)0x0;
  }
  else
  {
    r = PEM_read_RSAPrivateKey((FILE *)fp, (RSA **)0x0, (pem_password_cb *)0x0, (void *)0x0);
    if (r == (RSA *)0x0)
    {
      to = (uchar *)0x0;
    }
    else
    {
      flen = RSA_size(r);
      to = malloc(flen + 1);
      memset(to, 0, flen + 1);
      base64_decode(msg_buff, oldmessage_len, outstr2);
      RSA_private_decrypt(flen, (uchar *)outstr2, to, r, 1);
      RSA_free(r);
      __n = strlen("techmation+");
      strncmp("techmation+", (char *)to, __n);
    }
  }
  return (char *)to;
}

int __secs_to_tm(longlong t, tm *tm)

{
  int extraout_r1;
  int iVar1;
  int extraout_r2;
  int extraout_r2_00;
  int extraout_r2_01;
  uint uVar2;
  int iVar3;
  uint uVar4;
  bool bVar5;
  tm *tm_local;
  longlong t_local;
  longlong years;
  int leap;
  longlong secs;
  int yday;
  int wday;
  int months;
  int q_cycles;
  int c_cycles;
  int qc_cycles;
  int remyears;
  int remsecs;
  int remdays;
  longlong days;

  t_local._0_4_ = (uint)t;
  t_local._4_4_ = (int)((ulonglong)t >> 0x20);
  if ((t < -0xf1428000000000) ||
      ((int)(0xf1427f - (t_local._4_4_ + (uint)(0xfe1d7b00 < (uint)t_local))) < 0 !=
       (SBORROW4(0xf1427f, t_local._4_4_) !=
        SBORROW4(0xf1427f - t_local._4_4_, (uint)(0xfe1d7b00 < (uint)t_local)))))
  {
    return -1;
  }
  iVar1 = (int)(t + -0x38bc5d80);
  iVar3 = (int)((ulonglong)(t + -0x38bc5d80) >> 0x20);
  days._0_4_ = __aeabi_ldivmod(iVar1, iVar3, 0x15180, 0);
  __aeabi_ldivmod(iVar1, iVar3, 0x15180, 0);
  remsecs = extraout_r2;
  days._4_4_ = extraout_r1;
  if (extraout_r2 < 0)
  {
    remsecs = extraout_r2 + 0x15180;
    bVar5 = (uint)days == 0;
    days._0_4_ = (uint)days - 1;
    days._4_4_ = extraout_r1 - (uint)bVar5;
  }
  __aeabi_ldivmod((uint)days + 3, days._4_4_ + (uint)(0xfffffffc < (uint)days), 7, 0);
  wday = extraout_r2_00;
  if (extraout_r2_00 < 0)
  {
    wday = extraout_r2_00 + 7;
  }
  qc_cycles = __aeabi_ldivmod((uint)days, days._4_4_, 0x23ab1, 0);
  __aeabi_ldivmod((uint)days, days._4_4_, 0x23ab1, 0);
  remdays = extraout_r2_01;
  if (extraout_r2_01 < 0)
  {
    remdays = extraout_r2_01 + 0x23ab1;
    qc_cycles = qc_cycles + -1;
  }
  c_cycles = remdays / 0x8eac;
  if (c_cycles == 4)
  {
    c_cycles = 3;
  }
  iVar1 = remdays + c_cycles * -0x8eac;
  q_cycles = iVar1 / 0x5b5;
  if (q_cycles == 0x19)
  {
    q_cycles = 0x18;
  }
  iVar1 = iVar1 + q_cycles * -0x5b5;
  remyears = iVar1 / 0x16d;
  if (remyears == 4)
  {
    remyears = 3;
  }
  remdays = iVar1 + remyears * -0x16d;
  if ((remyears == 0) && ((q_cycles != 0 || (c_cycles == 0))))
  {
    iVar1 = 1;
  }
  else
  {
    iVar1 = 0;
  }
  yday = remdays + 0x3b + iVar1;
  if (iVar1 + 0x16d <= yday)
  {
    yday = yday - (iVar1 + 0x16d);
  }
  uVar4 = q_cycles * 4 + remyears + c_cycles * 100;
  uVar2 = qc_cycles * 400 + uVar4;
  iVar1 = (((((qc_cycles >> 0x1f) * 3 + (uint)CARRY4(qc_cycles, qc_cycles) +
              (uint)CARRY4(qc_cycles * 2, qc_cycles)) *
                 8 |
             (uint)(qc_cycles * 3) >> 0x1d) +
            (qc_cycles >> 0x1f) + (uint)CARRY4(qc_cycles * 0x18, qc_cycles)) *
               0x10 |
           (uint)(qc_cycles * 0x19) >> 0x1c) +
          ((int)uVar4 >> 0x1f) +
          (uint)CARRY4(qc_cycles * 400, uVar4);
  for (months = 0;
       (int)(uint)(byte) "\x1f\x1e\x1f\x1e\x1f\x1f\x1e\x1f\x1e\x1f\x1f\x1d"[months] <= remdays;
       months = months + 1)
  {
    remdays = remdays - (uint)(byte) "\x1f\x1e\x1f\x1e\x1f\x1f\x1e\x1f\x1e\x1f\x1f\x1d"[months];
  }
  iVar3 = iVar1 + (uint)(0xffffff9b < uVar2);
  bVar5 = 0x7fffffff < uVar2 + 100;
  if (((int)-(iVar3 + (uint)bVar5) < 0 == (SBORROW4(0, iVar3) != SBORROW4(-iVar3, (uint)bVar5))) &&
      (iVar1 = iVar1 + (uint)(0xffffff9b < uVar2), bVar5 = uVar2 + 100 < 0x80000000,
       (int)(iVar1 - (bVar5 - 1)) < 0 == (SBORROW4(iVar1, -1) != SBORROW4(iVar1 + 1, (uint)bVar5))))
  {
    tm->tm_year = uVar2 + 100;
    tm->tm_mon = months + 2;
    if (0xb < tm->tm_mon)
    {
      tm->tm_mon = tm->tm_mon + -0xc;
      tm->tm_year = tm->tm_year + 1;
    }
    tm->tm_mday = remdays + 1;
    tm->tm_wday = wday;
    tm->tm_yday = yday;
    tm->tm_hour = remsecs / 0xe10;
    tm->tm_min = (remsecs / 0x3c) % 0x3c;
    tm->tm_sec = remsecs % 0x3c;
    return 0;
  }
  return -1;
}

void DealTemperature(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  GetTemper((BYTE *)((int)pData + 0x10));
  put_value_0010_temper_set();
  put_value_0010_temper_current();
  return;
}

void DealMonitor(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  SendMonitor((BYTE *)((int)pData + 0x10));
  put_value_0011_monitor();
  return;
}

void DealUpdate(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  SendModify((BYTE *)((int)pData + 0x10));
  put_value_0013_UpdateCommon();
  return;
}

void DealHMIBound(void *pData, WORD wLength)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint64_t uVar3;
  uint64_t uVar4;
  DBVALUE DVar5;
  uint8_t auVar6[32];
  uint8_t auVar7[32];
  uint8_t in_stack_00000000[28];
  WORD wLength_local;
  void *pData_local;
  char test_name_ab[59][30];
  DBVALUE value_ab[59];
  ulong l_value_ab[14];
  ushort s_value_ab[44];
  char test_name_a[30][30];
  DBVALUE value_a[30];
  ulong l_value_a[8];
  ushort s_value_a[22];
  int i_1;
  int i;

  memset(s_value_a, 0, 0x2c);
  memset(l_value_a, 0, 0x20);
  memset(s_value_ab, 0, 0x58);
  memset(l_value_ab, 0, 0x38);
  if (u_recvbuff_length < 0x353)
  {
    memcpy(&bound_a, (void *)((int)pData + 0x260), 0xc0);
    memset(value_a, 0, 0x4b0);
    l_value_a[0] = bound_a.tmCycleTimeMax;
    value_a[0]._0_4_ = bound_a.tmCycleTimeMax & 0x7fffffff;
    memcpy(test_name_a, "tmCycleTimeMax", 0x14);
    l_value_a[1] = bound_a.tmInjTimeMax;
    value_a[1]._0_4_ = bound_a.tmInjTimeMax & 0x7fffffff;
    memcpy(test_name_a + 1, "tmInjTimeMax", 0x14);
    l_value_a[2] = bound_a.tmTurnTimeMax;
    value_a[2]._0_4_ = bound_a.tmTurnTimeMax & 0x7fffffff;
    memcpy(test_name_a + 2, "tmTurnTimeMax", 0x14);
    l_value_a[3] = bound_a.tmChargeTimeMax;
    value_a[3]._0_4_ = bound_a.tmChargeTimeMax & 0x7fffffff;
    memcpy(test_name_a + 3, "tmChargeTimeMax", 0x14);
    s_value_a[0] = bound_a.tmClpClsTimeMax;
    value_a[4]._0_2_ = (uint16_t)(((uint)bound_a.tmClpClsTimeMax << 0x11) >> 0x11);
    memcpy(test_name_a + 4, "tmClpClsTimeMax", 0x14);
    s_value_a[1] = bound_a.tmClpOpnPosiMax;
    value_a[5]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnPosiMax << 0x11) >> 0x11);
    memcpy(test_name_a + 5, "tmClpOpnPosiMax", 0x14);
    s_value_a[2] = bound_a.tmClpOpnTimeMax;
    value_a[6]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnTimeMax << 0x11) >> 0x11);
    memcpy(test_name_a + 6, "tmClpOpnTimeMax", 0x14);
    s_value_a[3] = bound_a.tmTurnPressMax;
    value_a[7]._0_2_ = (uint16_t)(((uint)bound_a.tmTurnPressMax << 0x11) >> 0x11);
    memcpy(test_name_a + 7, "tmTurnPressMax", 0x14);
    s_value_a[4] = bound_a.tmInjStartPosiMax;
    value_a[8]._0_2_ = (uint16_t)(((uint)bound_a.tmInjStartPosiMax << 0x11) >> 0x11);
    memcpy(test_name_a + 8, "tmInjStartPosiMax", 0x14);
    s_value_a[5] = bound_a.tmTurnPosiMax;
    value_a[9]._0_2_ = (uint16_t)(((uint)bound_a.tmTurnPosiMax << 0x11) >> 0x11);
    memcpy(test_name_a + 9, "tmTurnPosiMax", 0x14);
    s_value_a[6] = bound_a.tmInjEndPosiMax;
    value_a[10]._0_2_ = (uint16_t)(((uint)bound_a.tmInjEndPosiMax << 0x11) >> 0x11);
    memcpy(test_name_a + 10, "tmInjEndPosiMax", 0x14);
    s_value_a[7] = bound_a.tmInjBackTimeMax;
    value_a[0xb]._0_2_ = (uint16_t)(((uint)bound_a.tmInjBackTimeMax << 0x11) >> 0x11);
    memcpy(test_name_a + 0xb, "tmInjBackTimeMax", 0x14);
    s_value_a[8] = bound_a.tmEjectTimeMax;
    value_a[0xc]._0_2_ = (uint16_t)(((uint)bound_a.tmEjectTimeMax << 0x11) >> 0x11);
    memcpy(test_name_a + 0xc, "tmEjectTimeMax", 0x14);
    s_value_a[9] = bound_a.tmInjMaxPressMax;
    value_a[0xd]._0_2_ = (uint16_t)(((uint)bound_a.tmInjMaxPressMax << 0x11) >> 0x11);
    memcpy(test_name_a + 0xd, "tmInjMaxPressMax", 0x14);
    s_value_a[10] = bound_a.tmChargeMaxPressMax;
    value_a[0xe]._0_2_ = (uint16_t)(((uint)bound_a.tmChargeMaxPressMax << 0x11) >> 0x11);
    memcpy(test_name_a + 0xe, "tmChargeMaxPressMax", 0x14);
    l_value_a[4] = bound_a.tmCycleTimeMin;
    value_a[0xf]._0_4_ = bound_a.tmCycleTimeMin & 0x7fffffff;
    memcpy(test_name_a + 0xf, "tmCycleTimeMin", 0x14);
    l_value_a[5] = bound_a.tmInjTimeMin;
    value_a[0x10]._0_4_ = bound_a.tmInjTimeMin & 0x7fffffff;
    memcpy(test_name_a + 0x10, "tmInjTimeMin", 0x14);
    l_value_a[6] = bound_a.tmTurnTimeMin;
    value_a[0x11]._0_4_ = bound_a.tmTurnTimeMin & 0x7fffffff;
    memcpy(test_name_a + 0x11, "tmTurnTimeMin", 0x14);
    l_value_a[7] = bound_a.tmChargeTimeMin;
    value_a[0x12]._0_4_ = bound_a.tmChargeTimeMin & 0x7fffffff;
    memcpy(test_name_a + 0x12, "tmChargeTimeMin", 0x14);
    s_value_a[0xb] = bound_a.tmClpClsTimeMin;
    value_a[0x13]._0_2_ = (uint16_t)(((uint)bound_a.tmClpClsTimeMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x13, "tmClpClsTimeMin", 0x14);
    s_value_a[0xc] = bound_a.tmClpOpnPosiMin;
    value_a[0x14]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnPosiMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x14, "tmClpOpnPosiMin", 0x14);
    s_value_a[0xd] = bound_a.tmClpOpnTimeMin;
    value_a[0x15]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnTimeMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x15, "tmClpOpnTimeMin", 0x14);
    s_value_a[0xe] = bound_a.tmTurnPressMin;
    value_a[0x16]._0_2_ = (uint16_t)(((uint)bound_a.tmTurnPressMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x16, "tmTurnPressMin", 0x14);
    s_value_a[0xf] = bound_a.tmInjStartPosiMin;
    value_a[0x17]._0_2_ = (uint16_t)(((uint)bound_a.tmInjStartPosiMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x17, "tmInjStartPosiMin", 0x14);
    s_value_a[0x10] = bound_a.tmTurnPosiMin;
    value_a[0x18]._0_2_ = (uint16_t)(((uint)bound_a.tmTurnPosiMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x18, "tmTurnPosiMin", 0x14);
    s_value_a[0x11] = bound_a.tmInjEndPosiMin;
    value_a[0x19]._0_2_ = (uint16_t)(((uint)bound_a.tmInjEndPosiMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x19, "tmInjEndPosiMin", 0x14);
    s_value_a[0x12] = bound_a.tmInjBackTimeMin;
    value_a[0x1a]._0_2_ = (uint16_t)(((uint)bound_a.tmInjBackTimeMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x1a, "tmInjBackTimeMin", 0x14);
    s_value_a[0x13] = bound_a.tmEjectTimeMin;
    value_a[0x1b]._0_2_ = (uint16_t)(((uint)bound_a.tmEjectTimeMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x1b, "tmEjectTimeMin", 0x14);
    s_value_a[0x14] = bound_a.tmInjMaxPressMin;
    value_a[0x1c]._0_2_ = (uint16_t)(((uint)bound_a.tmInjMaxPressMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x1c, "tmInjMaxPressMin", 0x14);
    s_value_a[0x15] = bound_a.tmChargeMaxPressMin;
    value_a[0x1d]._0_2_ = (uint16_t)(((uint)bound_a.tmChargeMaxPressMin << 0x11) >> 0x11);
    memcpy(test_name_a + 0x1d, "tmChargeMaxPressMin", 0x14);
    for (i_1 = 0; i_1 < 0x1e; i_1 = i_1 + 1)
    {
      uVar2 = *(uint32_t *)((int)value_a + i_1 * 0x28 + 8);
      in_stack_00000000 = in_stack_00000000;
      auVar7 = CONCAT284(in_stack_00000000, uVar2);
      uVar4 = *(uint64_t *)(value_a + i_1);
      DVar5 = (DBVALUE)CONCAT328(auVar7, uVar4);
      compare_get_value(test_name_a[i_1], DVar5);
    }
  }
  else
  {
    memcpy(&bound_ab, (void *)((int)pData + 0x260), 0x180);
    memset(value_ab, 0, 0x938);
    l_value_ab[0] = bound_ab.tmCycleTimeMax;
    value_ab[0]._0_4_ = bound_ab.tmCycleTimeMax & 0x7fffffff;
    memcpy(test_name_ab, "tmCycleTimeMax", 0x14);
    l_value_ab[1] = bound_ab.tmInjTimeMax;
    value_ab[1]._0_4_ = bound_ab.tmInjTimeMax & 0x7fffffff;
    memcpy(test_name_ab + 1, "tmInjTimeMax", 0x14);
    l_value_ab[2] = bound_ab.tmTurnTimeMax;
    value_ab[2]._0_4_ = bound_ab.tmTurnTimeMax & 0x7fffffff;
    memcpy(test_name_ab + 2, "tmTurnTimeMax", 0x14);
    l_value_ab[3] = bound_ab.tmChargeTimeMax;
    value_ab[3]._0_4_ = bound_ab.tmChargeTimeMax & 0x7fffffff;
    memcpy(test_name_ab + 3, "tmChargeTimeMax", 0x14);
    s_value_ab[0] = bound_ab.tmClpClsTimeMax;
    value_ab[4]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpClsTimeMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 4, "tmClpClsTimeMax", 0x14);
    s_value_ab[1] = bound_ab.tmClpOpnPosiMax;
    value_ab[5]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpOpnPosiMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 5, "tmClpOpnPosiMax", 0x14);
    s_value_ab[2] = bound_ab.tmClpOpnTimeMax;
    value_ab[6]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpOpnTimeMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 6, "tmClpOpnTimeMax", 0x14);
    s_value_ab[3] = bound_ab.tmTurnPressMax;
    value_ab[7]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPressMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 7, "tmTurnPressMax", 0x14);
    s_value_ab[4] = bound_ab.tmInjStartPosiMax;
    value_ab[8]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjStartPosiMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 8, "tmInjStartPosiMax", 0x14);
    s_value_ab[5] = bound_ab.tmTurnPosiMax;
    value_ab[9]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPosiMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 9, "tmTurnPosiMax", 0x14);
    s_value_ab[6] = bound_ab.tmInjEndPosiMax;
    value_ab[10]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjEndPosiMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 10, "tmInjEndPosiMax", 0x14);
    s_value_ab[7] = bound_ab.tmInjBackTimeMax;
    value_ab[0xb]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjBackTimeMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 0xb, "tmInjBackTimeMax", 0x14);
    s_value_ab[8] = bound_ab.tmEjectTimeMax;
    value_ab[0xc]._0_2_ = (uint16_t)(((uint)bound_ab.tmEjectTimeMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 0xc, "tmEjectTimeMax", 0x14);
    s_value_ab[9] = bound_ab.tmInjMaxPressMax;
    value_ab[0xd]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjMaxPressMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 0xd, "tmInjMaxPressMax", 0x14);
    s_value_ab[10] = bound_ab.tmChargeMaxPressMax;
    value_ab[0xe]._0_2_ = (uint16_t)(((uint)bound_ab.tmChargeMaxPressMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 0xe, "tmChargeMaxPressMax", 0x14);
    l_value_ab[4] = bound_ab.tmCycleTimeMin;
    value_ab[0xf]._0_4_ = bound_ab.tmCycleTimeMin & 0x7fffffff;
    memcpy(test_name_ab + 0xf, "tmCycleTimeMin", 0x14);
    l_value_ab[5] = bound_ab.tmInjTimeMin;
    value_ab[0x10]._0_4_ = bound_ab.tmInjTimeMin & 0x7fffffff;
    memcpy(test_name_ab + 0x10, "tmInjTimeMin", 0x14);
    l_value_ab[6] = bound_ab.tmTurnTimeMin;
    value_ab[0x11]._0_4_ = bound_ab.tmTurnTimeMin & 0x7fffffff;
    memcpy(test_name_ab + 0x11, "tmTurnTimeMin", 0x14);
    l_value_ab[7] = bound_ab.tmChargeTimeMin;
    value_ab[0x12]._0_4_ = bound_ab.tmChargeTimeMin & 0x7fffffff;
    memcpy(test_name_ab + 0x12, "tmChargeTimeMin", 0x14);
    s_value_ab[0xb] = bound_ab.tmClpClsTimeMin;
    value_ab[0x13]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpClsTimeMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x13, "tmClpClsTimeMin", 0x14);
    s_value_ab[0xc] = bound_ab.tmClpOpnPosiMin;
    value_ab[0x14]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpOpnPosiMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x14, "tmClpOpnPosiMin", 0x14);
    s_value_ab[0xd] = bound_ab.tmClpOpnTimeMin;
    value_ab[0x15]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpOpnTimeMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x15, "tmClpOpnTimeMin", 0x14);
    s_value_ab[0xe] = bound_ab.tmTurnPressMin;
    value_ab[0x16]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPressMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x16, "tmTurnPressMin", 0x14);
    s_value_ab[0xf] = bound_ab.tmInjStartPosiMin;
    value_ab[0x17]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjStartPosiMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x17, "tmInjStartPosiMin", 0x14);
    s_value_ab[0x10] = bound_ab.tmTurnPosiMin;
    value_ab[0x18]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPosiMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x18, "tmTurnPosiMin", 0x14);
    s_value_ab[0x11] = bound_ab.tmInjEndPosiMin;
    value_ab[0x19]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjEndPosiMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x19, "tmInjEndPosiMin", 0x14);
    s_value_ab[0x12] = bound_ab.tmInjBackTimeMin;
    value_a[0x1a]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjBackTimeMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x1a, "tmInjBackTimeMin", 0x14);
    s_value_ab[0x13] = bound_ab.tmEjectTimeMin;
    value_ab[0x1b]._0_2_ = (uint16_t)(((uint)bound_ab.tmEjectTimeMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x1b, "tmEjectTimeMin", 0x14);
    s_value_ab[0x14] = bound_ab.tmInjMaxPressMin;
    value_ab[0x1c]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjMaxPressMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x1c, "tmInjMaxPressMin", 0x14);
    s_value_ab[0x15] = bound_ab.tmChargeMaxPressMin;
    value_ab[0x1d]._0_2_ = (uint16_t)(((uint)bound_ab.tmChargeMaxPressMin << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x1d, "tmChargeMaxPressMin", 0x14);
    l_value_ab[8] = bound_ab.tmInjTimeMaxB;
    value_ab[0x1e]._0_4_ = bound_ab.tmInjTimeMaxB & 0x7fffffff;
    memcpy(test_name_ab + 0x1e, "tmInjTimeMaxB", 0x14);
    l_value_ab[9] = bound_ab.tmTurnTimeMaxB;
    value_ab[0x1f]._0_4_ = bound_ab.tmTurnTimeMaxB & 0x7fffffff;
    memcpy(test_name_ab + 0x1f, "tmTurnTimeMaxB", 0x14);
    l_value_ab[10] = bound_ab.tmChargeTimeMaxB;
    value_ab[0x20]._0_4_ = bound_ab.tmChargeTimeMaxB & 0x7fffffff;
    memcpy(test_name_ab + 0x20, "tmChargeTimeMaxB", 0x14);
    s_value_ab[0x16] = bound_ab.tmTurnPressMaxB;
    value_ab[0x21]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPressMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x21, "tmTurnPressMaxB", 0x14);
    s_value_ab[0x17] = bound_ab.tmInjStartPosiMaxB;
    value_ab[0x22]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjStartPosiMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x22, "tmInjStartPosiMaxB", 0x14);
    s_value_ab[0x18] = bound_ab.tmTurnPosiMaxB;
    value_ab[0x23]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPosiMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x23, "tmTurnPosiMaxB", 0x14);
    s_value_ab[0x19] = bound_ab.tmInjEndPosiMaxB;
    value_ab[0x24]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjEndPosiMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x24, "tmInjEndPosiMaxB", 0x14);
    s_value_ab[0x1a] = bound_ab.tmInjBackTimeMaxB;
    value_ab[0x25]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjBackTimeMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x25, "tmInjBackTimeMaxB", 0x14);
    s_value_ab[0x1b] = bound_ab.tmEjectTimeMaxB;
    value_ab[0x26]._0_2_ = (uint16_t)(((uint)bound_ab.tmEjectTimeMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x26, "tmEjectTimeMaxB", 0x14);
    s_value_ab[0x1c] = bound_ab.tmInjMaxPressMaxB;
    value_ab[0x27]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjMaxPressMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x27, "tmInjMaxPressMaxB", 0x14);
    s_value_ab[0x1d] = bound_ab.tmChargeMaxPressMaxB;
    value_ab[0x28]._0_2_ = (uint16_t)(((uint)bound_ab.tmChargeMaxPressMaxB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x28, "tmChargeMaxPressMaxB", 0x14);
    l_value_ab[0xb] = bound_ab.tmInjTimeMinB;
    value_ab[0x29]._0_4_ = bound_ab.tmInjTimeMinB & 0x7fffffff;
    memcpy(test_name_ab + 0x29, "tmInjTimeMinB", 0x14);
    l_value_ab[0xc] = bound_ab.tmTurnTimeMinB;
    value_ab[0x2a]._0_4_ = bound_ab.tmTurnTimeMinB & 0x7fffffff;
    memcpy(test_name_ab + 0x2a, "tmTurnTimeMinB", 0x14);
    l_value_ab[0xd] = bound_ab.tmChargeTimeMinB;
    value_ab[0x2b]._0_4_ = bound_ab.tmChargeTimeMinB & 0x7fffffff;
    memcpy(test_name_ab + 0x2b, "tmChargeTimeMinB", 0x14);
    s_value_ab[0x1e] = bound_ab.tmTurnPressMinB;
    value_ab[0x2c]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPressMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x2c, "tmTurnPressMinB", 0x14);
    s_value_ab[0x1f] = bound_ab.tmInjStartPosiMinB;
    value_ab[0x2d]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjStartPosiMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x2d, "tmInjStartPosiMinB", 0x14);
    s_value_ab[0x20] = bound_ab.tmTurnPosiMinB;
    value_ab[0x2f]._0_2_ = (uint16_t)(((uint)bound_ab.tmTurnPosiMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x2f, "tmTurnPosiMinB", 0x14);
    s_value_ab[0x21] = bound_ab.tmInjEndPosiMinB;
    value_ab[0x30]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjEndPosiMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x30, "tmInjEndPosiMinB", 0x14);
    s_value_ab[0x22] = bound_ab.tmInjBackTimeMinB;
    value_ab[0x31]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjBackTimeMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x31, "tmInjBackTimeMinB", 0x14);
    s_value_ab[0x23] = bound_ab.tmEjectTimeMinB;
    value_ab[0x32]._0_2_ = (uint16_t)(((uint)bound_ab.tmEjectTimeMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x32, "tmEjectTimeMinB", 0x14);
    s_value_ab[0x24] = bound_ab.tmInjMaxPressMinB;
    value_ab[0x33]._0_2_ = (uint16_t)(((uint)bound_ab.tmInjMaxPressMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x33, "tmInjMaxPressMinB", 0x14);
    s_value_ab[0x25] = bound_ab.tmChargeMaxPressMinB;
    value_ab[0x34]._0_2_ = (uint16_t)(((uint)bound_ab.tmChargeMaxPressMinB << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x34, "tmChargeMaxPressMinB", 0x14);
    s_value_ab[0x26] = bound_ab.tmClpOpnTimeMax;
    value_ab[0x35]._0_2_ = (uint16_t)(((uint)bound_ab.tmClpOpnTimeMax << 0x11) >> 0x11);
    memcpy(test_name_ab + 0x35, "tmClpOpnTimeMaxB", 0x14);
    s_value_ab[0x27] = bound_a.tmClpOpnPosiMax;
    value_ab[0x36]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnPosiMax << 0x11) >> 0x11);
    memcpy(value_a + 0x12, "tmClpOpnPosiMaxB", 0x14);
    s_value_ab[0x28] = bound_a.tmEjectTimeMax;
    value_ab[0x37]._0_2_ = (uint16_t)(((uint)bound_a.tmEjectTimeMax << 0x11) >> 0x11);
    memcpy((void *)((int)value_a + 0x2ee), "tmEjectTimeMaxB", 0x14);
    s_value_ab[0x29] = bound_a.tmClpOpnTimeMin;
    value_ab[0x38]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnTimeMin << 0x11) >> 0x11);
    memcpy((void *)((int)value_a + 0x30c), "tmClpOpnTimeMinB", 0x14);
    s_value_ab[0x2a] = bound_a.tmClpOpnPosiMin;
    value_ab[0x39]._0_2_ = (uint16_t)(((uint)bound_a.tmClpOpnPosiMin << 0x11) >> 0x11);
    memcpy((void *)((int)value_a + 0x32a), "tmClpOpnPosiMinB", 0x14);
    s_value_ab[0x2b] = bound_a.tmEjectTimeMin;
    value_ab[0x3a]._0_2_ = (uint16_t)(((uint)bound_a.tmEjectTimeMin << 0x11) >> 0x11);
    memcpy(value_a + 0x15, "tmEjectTimeMinB", 0x14);
    for (i = 0; i < 0x3b; i = i + 1)
    {
      uVar1 = *(uint32_t *)((int)value_ab + i * 0x28 + 8);
      in_stack_00000000 = in_stack_00000000;
      auVar6 = CONCAT284(in_stack_00000000, uVar1);
      uVar3 = *(uint64_t *)(value_ab + i);
      DVar5 = (DBVALUE)CONCAT328(auVar6, uVar3);
      compare_get_value(test_name_ab[i], DVar5);
    }
  }
  return;
}

void DealError(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  SendError((BYTE *)((int)pData + 0x10));
  put_value_0021_error();
  return;
}

void DealEnergy(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  GetEnergy((BYTE *)((int)pData + 0x10));
  put_value_0026_energy();
  return;
}

void DealMachineStatus(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  SendOPState((BYTE *)((int)pData + 0x10));
  DAT_00159c00 = *(uint32_t *)((int)pData + 0x1a);
  put_value_0040_instant();
  g_send_to_hmi_offline = 10000;
  return;
}

void DealInferiorStatus(void *pData, WORD wLength)

{
  uint32_t uVar1;
  uint32_t uVar2;
  uint32_t uVar3;
  uint64_t uVar4;
  DBVALUE value_00;
  uint8_t auVar5[32];
  uint8_t in_stack_00000000[28];
  WORD wLength_local;
  void *pData_local;
  DBVALUE value[1];
  DWORD_T Inferior_count;

  uVar2 = value[0]._4_4_;
  uVar1 = *(uint32_t *)((int)pData + 0x26);
  uVar4 = CONCAT44(uVar2, uVar1);
  uVar3 = value[0]._8_4_;
  auVar5 = CONCAT284(in_stack_00000000, uVar3);
  value_00 = (DBVALUE)CONCAT328(auVar5, uVar4);
  compare_get_value("tmInferior", value_00);
  return;
}

void DealXml(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  GetXml((BYTE *)((int)pData + 0x10));
  put_value_0026_energy();
  return;
}

void DealidentificationA(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;
  WORD data;
  INTHEADER *pInetHeader;

  *(uint32_t *)((int)pData + 8) = 1;
  *(uint32_t *)((int)pData + 0xc) = 0x200000a;
  *(uint16_t *)((int)pData + 2) = 0x16;
  *(uint16_t *)((int)pData + 0x10) = 0xff;
  testdw_id = GetCRC32(pData, 0x12);
  nCRC = testdw_id;
  *(ulong *)((int)pData + 0x12) = testdw_id;
  sendto(sockfd, pData, 0x16, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void DealidentificationB(void *pData, WORD wLength)

{
  char *msg_buff;
  WORD wLength_local;
  void *pData_local;
  char *decryptMsg;

  // Unresolved local var: char * finalMsg@[???]
  if (wLength < 0x65)
  {
    msg_buff = Dealidentification_self(pData, wLength);
    encry(pData, msg_buff);
  }
  else
  {
    Dealidentification_rsa(pData, wLength);
  }
  return;
}

void DealVersion(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  g_machine_type = *(WORD *)((int)pData + 0x1a);
  g_style_type = *(WORD *)((int)pData + 0x1c);
  g_MAX_Temp = *(WORD *)((int)pData + 0x20);
  g_SPEED_Precious._0_2_ = *(uint16_t *)((int)pData + 0x22);
  g_Position_Precious._0_2_ = *(uint16_t *)((int)pData + 0x2e);
  g_get_SPEED_Precious = 1;
  g_get_Position_Precious = 1;
  SendBoundApplication();
  return;
}

void DealHMIproVersion(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  g_HMIversion[0] = *(char *)((int)pData + 0x11);
  g_HMIversion[1] = *(char *)((int)pData + 0x10);
  g_hmiversion_flag = '\x01';
  if (0x37 < wLength)
  {
    g_u16Version = *(uint16_t *)((int)pData + 0x36);
  }
  return;
}

void DealGetMachine(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  return;
}

void DealGetMoldset(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;

  GetMoldSet(pData);
  put_value_0121_moldset();
  return;
}

void DealOnLineStatus(void *pData, WORD wLength)

{
  WORD wLength_local;
  void *pData_local;
  WORD data;
  INTHEADER *pInetHeader;

  *(uint32_t *)((int)pData + 8) = 1;
  *(byte *)((int)pData + 0xf) = *(byte *)((int)pData + 0xf) & 0x3f;
  *(uint8_t *)((int)pData + 0xe) = 0;
  *(byte *)((int)pData + 0xf) = *(byte *)((int)pData + 0xf) & 0xc0;
  *(uint16_t *)((int)pData + 0xc) = 0;
  *(uint16_t *)((int)pData + 2) = 0x16;
  *(uint16_t *)((int)pData + 0x10) = 1;
  testdw_id = GetCRC32(pData, 0x12);
  nCRC = testdw_id;
  *(ulong *)((int)pData + 0x12) = testdw_id;
  sendto(sockfd, pData, 0x16, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void DealLineStatus(void *pData, WORD wLength)

{
  int iVar1;
  int iVar2;
  uint32_t *puVar3;
  tm *ptVar4;
  uint32_t uVar5;
  uint uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  int iVar10;
  int iVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  char *pcVar15;
  char *pcVar16;
  uint32_t *puVar17;
  WORD wLength_local;
  void *pData_local;
  time_t tt_local;
  int wensday;
  int msec;
  int sec;
  int min;
  int hour;
  int day;
  int month;
  int year;
  char syscmdtime[128];
  char IP_flag[9];
  char g_byData_sg[28];
  char g_byData[46];
  INTHEADER *pInetHeader;
  tm *t_local;

  pcVar16 = g_byData;
  puVar3 = &DAT_0011b7a0;
  do
  {
    puVar17 = puVar3;
    pcVar15 = pcVar16;
    uVar7 = puVar17[1];
    uVar8 = puVar17[2];
    uVar9 = puVar17[3];
    *(uint32_t *)pcVar15 = *puVar17;
    *(uint32_t *)(pcVar15 + 4) = uVar7;
    *(uint32_t *)(pcVar15 + 8) = uVar8;
    *(uint32_t *)(pcVar15 + 0xc) = uVar9;
    pcVar16 = pcVar15 + 0x10;
    puVar3 = puVar17 + 4;
  } while (puVar17 + 4 != &DAT_0011b7c0);
  uVar7 = puVar17[5];
  uVar8 = puVar17[6];
  pcVar16[0] = '(';
  pcVar16[1] = '\0';
  pcVar16[2] = -0x3f;
  pcVar16[3] = '\x03';
  *(uint32_t *)(pcVar15 + 0x14) = uVar7;
  *(uint32_t *)(pcVar15 + 0x18) = uVar8;
  *(uint16_t *)(pcVar15 + 0x1c) = *(uint16_t *)(puVar17 + 7);
  g_byData_sg[4] = '\0';
  g_byData_sg[5] = '\0';
  g_byData_sg[6] = '\0';
  g_byData_sg[7] = '\0';
  g_byData_sg[0x10] = '\0';
  g_byData_sg[0x11] = '\0';
  g_byData_sg[0x12] = '\0';
  g_byData_sg[0x13] = '\0';
  g_byData_sg[0x14] = '\0';
  g_byData_sg[0x15] = '\0';
  g_byData_sg[0x16] = '\0';
  g_byData_sg[0x17] = '\0';
  g_byData_sg[0x18] = '\0';
  g_byData_sg[0x19] = '\0';
  g_byData_sg[0x1a] = '\0';
  g_byData_sg[0x1b] = '\0';
  g_byData_sg[0] = '\x02';
  g_byData_sg[1] = '\0';
  g_byData_sg[2] = '\0';
  g_byData_sg[3] = '\0';
  g_byData_sg[8] = '\x01';
  g_byData_sg[9] = '\0';
  g_byData_sg[10] = '\0';
  g_byData_sg[0xb] = '\0';
  g_byData_sg[0xc] = '\x01';
  g_byData_sg[0xd] = '\0';
  g_byData_sg[0xe] = '\0';
  g_byData_sg[0xf] = '\x01';
  msec = 0x14;
  wensday = 7;
  time(&tt_local);
  ptVar4 = localtime(&tt_local);
  iVar2 = msec;
  iVar1 = wensday;
  iVar10 = ptVar4->tm_year + 0x76c;
  iVar11 = ptVar4->tm_mon + 1;
  year._0_2_ = (uint16_t)iVar10;
  g_byData[0x14] = (char)year;
  g_byData[0x15] = year._1_1_;
  month._0_2_ = (uint16_t)iVar11;
  g_byData[0x16] = (char)month;
  g_byData[0x17] = month._1_1_;
  g_byData[0x18] = (char)wensday;
  g_byData[0x19] = wensday._1_1_;
  day._0_2_ = (uint16_t)ptVar4->tm_mday;
  g_byData[0x1a] = (char)day;
  g_byData[0x1b] = day._1_1_;
  hour._0_2_ = (uint16_t)ptVar4->tm_hour;
  g_byData[0x1c] = (char)hour;
  g_byData[0x1d] = hour._1_1_;
  min._0_2_ = (uint16_t)ptVar4->tm_min;
  g_byData[0x1e] = (char)min;
  g_byData[0x1f] = min._1_1_;
  sec._0_2_ = (uint16_t)ptVar4->tm_sec;
  g_byData[0x20] = (char)sec;
  g_byData[0x21] = sec._1_1_;
  g_byData[0x22] = (char)msec;
  g_byData[0x23] = msec._1_1_;
  wensday = iVar1;
  msec = iVar2;
  sec = ptVar4->tm_sec;
  min = ptVar4->tm_min;
  hour = ptVar4->tm_hour;
  day = ptVar4->tm_mday;
  month = iVar11;
  year = iVar10;
  uVar5 = htonl(adr_inet.sin_addr.s_addr);
  g_HMI_ip_address_new[0] = uVar5 >> 0x18;
  uVar5 = htonl(adr_inet.sin_addr.s_addr);
  g_HMI_ip_address_new[1] = uVar5 >> 0x10 & 0xff;
  uVar5 = htonl(adr_inet.sin_addr.s_addr);
  g_HMI_ip_address_new[2] = uVar5 >> 8 & 0xff;
  uVar5 = htonl(adr_inet.sin_addr.s_addr);
  g_HMI_ip_address_new[3] = uVar5 & 0xff;
  uVar5 = htonl(adr_clnt.sin_addr.s_addr);
  g_HMI_ip_address_old[0] = uVar5 >> 0x18;
  uVar5 = htonl(adr_clnt.sin_addr.s_addr);
  g_HMI_ip_address_old[1] = uVar5 >> 0x10 & 0xff;
  uVar5 = htonl(adr_clnt.sin_addr.s_addr);
  g_HMI_ip_address_old[2] = uVar5 >> 8 & 0xff;
  uVar5 = htonl(adr_clnt.sin_addr.s_addr);
  g_HMI_ip_address_old[3] = uVar5 & 0xff;
  memcpy(g_byData + 0x24, (void *)((int)pData + 0x10), 6);
  g_HMI_ip_address[0] = g_HMI_ip_address_new[0];
  iVar1 = g_HMI_ip_address[0];
  g_HMI_ip_address[1] = g_HMI_ip_address_new[1];
  iVar2 = g_HMI_ip_address[1];
  g_HMI_ip_address[2] = g_HMI_ip_address_new[2];
  iVar10 = g_HMI_ip_address[2];
  if (g_HMI_ip_address_new[3] == 0xff)
  {
    g_HMI_ip_address[3] = 0xfe;
  }
  else if (g_HMI_ip_address_new[3] == 0xfe)
  {
    g_HMI_ip_address[3] = 0xfd;
  }
  else
  {
    g_HMI_ip_address[3] = g_HMI_ip_address_new[3] + 1;
  }
  g_HMI_ip_address[0]._0_1_ = (char)g_HMI_ip_address_new[0];
  g_byData[0x10] = (char)g_HMI_ip_address[0];
  g_HMI_ip_address[1]._0_1_ = (char)g_HMI_ip_address_new[1];
  g_byData[0x11] = (char)g_HMI_ip_address[1];
  g_HMI_ip_address[2]._0_1_ = (char)g_HMI_ip_address_new[2];
  g_byData[0x12] = (char)g_HMI_ip_address[2];
  g_byData[0x13] = (char)g_HMI_ip_address[3];
  uVar6 = *(uint *)((int)pData + 0x10);
  g_MAC_address._4_2_ = *(uint16_t *)((int)pData + 0x14);
  g_MAC_address[1] = (char)(uVar6 >> 8);
  g_MAC_address[2] = (char)(uVar6 >> 0x10);
  g_MAC_address[3] = (char)(uVar6 >> 0x18);
  g_MAC_address._0_4_ = uVar6;
  g_HMI_ip_address[0] = iVar1;
  g_HMI_ip_address[1] = iVar2;
  g_HMI_ip_address[2] = iVar10;
  if (*(char *)((int)pData + 6) == '\x01')
  {
    uVar12 = (uint)(byte)g_MAC_address[1];
    uVar13 = (uint)(byte)g_MAC_address[2];
    uVar14 = (uint)(byte)g_MAC_address[3];
    sprintf(syscmdtime, "arp -s  %d.%d.%d.%d  %02X%02X%02X%02X%02X%02X", g_HMI_ip_address_new[0],
            g_HMI_ip_address_new[1], g_HMI_ip_address_new[2], g_HMI_ip_address[3], uVar6 & 0xff, uVar12,
            uVar13, uVar14, (uint)(byte)g_MAC_address[4], (uint)(byte)g_MAC_address[5]);
    uVar6 = g_MAC_address._0_4_;
  }
  else if (*(char *)((int)pData + 6) == '\0')
  {
    uVar12 = (uint)(byte)g_MAC_address[1];
    uVar13 = (uint)(byte)g_MAC_address[2];
    uVar14 = (uint)(byte)g_MAC_address[3];
    sprintf(syscmdtime, "arp -s  %d.%d.%d.%d  %02X:%02X:%02X:%02X:%02X:%02X", g_HMI_ip_address_new[0],
            g_HMI_ip_address_new[1], g_HMI_ip_address_new[2], g_HMI_ip_address[3], uVar6 & 0xff, uVar12,
            uVar13, uVar14, (uint)(byte)g_MAC_address[4], (uint)(byte)g_MAC_address[5]);
    system(syscmdtime);
    usleep(100);
    system(syscmdtime);
    sprintf(g_HMI_ip_address_52_ip, "%d.%d.%d.%d", g_HMI_ip_address[0], g_HMI_ip_address[1],
            g_HMI_ip_address[2], g_HMI_ip_address[3]);
    uVar6 = g_MAC_address._0_4_;
  }
  g_MAC_address._0_4_ = uVar6;
  *(uint32_t *)((int)pData + 8) = 1;
  *(uint32_t *)((int)pData + 0xc) = 0x1000000;
  *(uint16_t *)((int)pData + 2) = 0x2e;
  memcpy(g_byData, pData, 0x10);
  testdw_id = GetCRC32(g_byData, 0x2a);
  nCRC = testdw_id;
  g_byData._42_4_ = testdw_id;
  sendto(sockfd, g_byData, 0x2e, 0, (sockaddr *)&adr_clnt, 0x10);
  usleep(300);
  *(uint32_t *)((int)pData + 8) = 1;
  *(uint32_t *)((int)pData + 0xc) = 0x1000001;
  *(uint16_t *)((int)pData + 2) = 0x1c;
  testdw_id = GetCRC32(g_byData_sg, 0x18);
  nCRC = testdw_id;
  g_byData_sg._24_4_ = testdw_id;
  memcpy(g_byData_sg, pData, 0x10);
  sendto(sockfd, g_byData_sg, 0x1c, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void DealGetUser(void *pData, WORD wLength)

{
  int iVar1;
  WORD wLength_local;
  void *pData_local;
  WORD wValue;
  INTHEADER InetHeader;
  char szUser[8];
  WORD wLen;
  DWORD dwUser;
  int i;

  szUser[0] = '\0';
  szUser[1] = '\0';
  szUser[2] = '\0';
  szUser[3] = '\0';
  szUser[4] = '\0';
  szUser[5] = '\0';
  szUser[6] = '\0';
  szUser[7] = '\0';
  InetHeader.dwVersion = 2;
  InetHeader.dwReserved = 0;
  InetHeader.dwDirection = 1;
  InetHeader.DataType.dwDataType = 0x1030000;
  memset(u_bySendData, 0, 0x5c8);
  memcpy(u_bySendData, &InetHeader, 0x10);
  sprintf(szUser, (char *)((int)pData + 0x10), 8);
  i = 0;
  while (true)
  {
    if (3 < (uint)i)
    {
      return;
    }
    iVar1 = strcmp(szUser, u_aUserTable[i].szUserID);
    if (iVar1 == 0)
      break;
    i = i + 1;
  }
  u_bySendData[0x10] = '\x01';
  u_bySendData[0x11] = '\0';
  u_bySendData._18_2_ = u_aUserTable[i].wPriv;
  memcpy(u_bySendData + 0x14, u_aUserTable[i].szPassword, 8);
  memcpy(u_bySendData + 0x1c, u_aUserTable[i].szName, 8);
  testdw_id = GetCRC32((char *)u_bySendData, 0x24);
  InetHeader.dwLength = 0x28;
  nCRC = testdw_id;
  u_bySendData._36_4_ = testdw_id;
  sendto(sockfd, u_bySendData, 0x28, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void compare_get_value(char *name, DBVALUE value)

{
  int iVar1;
  char *name_local;
  int i;
  uint8_t local_c[12];

  i = 0;
  while (true)
  {
    if (0x1fd < i)
    {
      return;
    }
    value._8_4_ = *(uint32_t *)(&DAT_001594ec + i * 0x40);
    iVar1 = strcmp(name, (char *)value._8_4_);
    if (iVar1 == 0)
      break;
    value._8_4_ = i + 1;
    i = value._8_4_;
  }
  if ((&DAT_001594f9)[i * 0x40] == '\x01')
  {
    value._8_4_ = &DBdata + i * 0x20;
    memset((void *)value._8_4_, 0, 0x28);
  }
  value._8_4_ = &DBdata + i * 0x20;
  value.ldata = (ulong)local_c;
  memcpy((void *)value._8_4_, (void *)value.ldata, 0x28);
  return;
}

void *pthread_inet(void)

{
  byte bVar1;
  size_t __n;
  int iVar2;
  uint32_t uVar3;
  uint32_t uVar4;
  uint64_t uVar5;
  uint64_t uVar6;
  DBVALUE DVar7;
  uint8_t auVar8[32];
  uint8_t auVar9[32];
  uint8_t in_stack_00000000[28];
  int NO_fragementoffset;
  DBVALUE value[2];
  char mg[256];
  char msg[256];
  char buf[8192];
  int len;
  int z;
  uint8_t u8DYUpdateFlag;
  char *test_eth1;
  char *test_eth0;
  ushort data_len;
  ulong dwid;
  int ret;
  int i;
  int y;
  int k;
  int r;
  int u;

  // Unresolved local var: int i@[???]
  // Unresolved local var: uint nCRC@[???]
  // Unresolved local var: ulong testid@[???]
  // Unresolved local var: ulong testdw_id@[???]
  // Unresolved local var: int length@[???]
  // Unresolved local var: ushort wtest_count@[???]
  // Unresolved local var: ushort nwtest_count@[???]
  ret = 0;
  dwid = 0;
  data_len = 0;
  CreateCRC32Table();
  test_eth0 = "eth0";
  test_eth1 = "eth1";
  u8DYUpdateFlag = '\x01';
  get_local_ip("eth1", g_opc_ua_server_ip);
  get_local_ip(test_eth0, g_inet_server_ip);
  get_local_mac(test_eth1, opc_ua_mac_700);
  pthread_mutex_init((pthread_mutex_t *)&mutexlock, (pthread_mutexattr_t *)0x0);
  memcpy(g_opc_ua_mac, (void *)((int)&g_700_mac_ifr.ifr_ifru + 2), 6);
  if ((((g_700_mac_ifr.ifr_ifru.ifru_addr.sa_data[0] != -0x6c) ||
        (g_700_mac_ifr.ifr_ifru.ifru_addr.sa_data[1] != -0x2e)) ||
       (g_700_mac_ifr.ifr_ifru.ifru_addr.sa_data[2] != -0x67)) ||
      (g_700_mac_ifr.ifr_ifru.ifru_addr.sa_data[3] != '\x1f'))
  {
    // WARNING: Subroutine does not return
    exit(1);
  }
  FindtmClpSPMode();
  ret = parseMoldData_54_52_xml(molddata_54_52_file_name);
  CurrentMoldData54_52Count = ret;
  if (ret == -1)
  {
    CurrentMoldData54_52Count = 1000;
  }
  logDebug("CurrentMoldData54_52Count: %d\n", CurrentMoldData54_52Count);
  memset(value, 0, 0x28);
  sprintf(value[0].string, "%s_%s", "MoldData_54_52.xml", CurrentMoldCfgFileVer);
  uVar3 = value[0]._8_4_;
  auVar8 = CONCAT284(in_stack_00000000, uVar3);
  uVar5 = value[0]._0_8_;
  DVar7 = (DBVALUE)CONCAT328(auVar8, uVar5);
  compare_get_value("tmMoldCfgFileVer", DVar7);
  memset(value + 1, 0, 0x28);
  __n = strlen(CurrentMoldCfgFileDataTime);
  memcpy(value + 1, CurrentMoldCfgFileDataTime, __n);
  in_stack_00000000 = in_stack_00000000;
  uVar4 = value[1]._8_4_;
  auVar9 = CONCAT284(in_stack_00000000, uVar4);
  uVar6 = value[1]._0_8_;
  DVar7 = (DBVALUE)CONCAT328(auVar9, uVar6);
  compare_get_value("tmMoldCfgFileDataTime", DVar7);
  memset(msg, 0, 0x100);
  memset(buf, 0, 0x2000);
  memset(send_buff, 0, 0x578);
  adr_inet.sin_family = 2;
  adr_inet.sin_addr.s_addr = inet_addr(g_inet_server_ip);
  adr_inet.sin_port = htons(0x3039);
  len = 0x10;
  sockfd = socket(2, 2, 0);
  if (sockfd == -1)
  {
    perror(&DAT_0011b850);
    // WARNING: Subroutine does not return
    exit(1);
  }
  z = bind(sockfd, (sockaddr *)&adr_inet, 0x10);
  if (z == -1)
  {
    perror(&DAT_0011b860);
    // WARNING: Subroutine does not return
    exit(1);
  }
  NO_fragementoffset = 0;
  setsockopt(sockfd, 0, 10, &NO_fragementoffset, 4);
  for (u = 0; u < 0x20; u = u + 1)
  {
    (&DAT_001594f8)[(u + 0x22) * 0x40] = precision_54_52[u * 8 + 4];
  }
  DAT_0015a778 = precision_54_52[0x104];
  do
  {
    u_recvbuff_length = recvfrom(sockfd, buf, 0x2000, 0, (sockaddr *)&adr_clnt, (socklen_t *)&len);
    if (u_recvbuff_length < 0)
    {
      perror(&DAT_0011b870);
    }
    if (g_get_SPEED_Precious == 1)
    {
      g_get_SPEED_Precious = 0;
      for (r = 0; r < CurrentMoldData54_52Count; r = r + 1)
      {
        bVar1 = DBdata_54_52[r].Precision54;
        if (bVar1 == 0xb)
        {
          if (g_SPEED_Precious == 999)
          {
            g_modepara_preci[r] = '\x01';
          }
          else
          {
            g_modepara_preci[r] = '\0';
          }
        }
        else if (bVar1 < 0xc)
        {
          if (bVar1 == 1)
          {
            g_modepara_preci[r] = '\0';
          }
          else if (bVar1 == 10)
          {
            g_modepara_preci[r] = '\x01';
          }
        }
        else if (bVar1 == 100)
        {
          g_modepara_preci[r] = '\x02';
        }
        else if (bVar1 == 0x65)
        {
          g_modepara_preci[r] = '\x02';
        }
      }
      for (k = 0; k < CurrentMoldData54_52Count; k = k + 1)
      {
        for (y = 0; y < 0x1fe; y = y + 1)
        {
          iVar2 = strcmp(DBdata_54_52[k].Name, *(char **)(&DAT_001594ec + y * 0x40));
          if (iVar2 == 0)
          {
            (&DAT_001594f8)[y * 0x40] = g_modepara_preci[k];
            break;
          }
        }
      }
    }
    if (g_get_Position_Precious == 1)
    {
      g_get_Position_Precious = 0;
    }
    dwid = ParaseNetData_HMI(buf, u_recvbuff_length);
    for (i = 0; (uint)i < 0x12; i = i + 1)
    {
      if ((u_aHMICommMap[i].dwProtocolID == dwid) && (u_aHMICommMap[i].pFunc != (pFUNC)0x0))
      {
        (*u_aHMICommMap[i].pFunc)(buf, (WORD)u_recvbuff_length);
        break;
      }
    }
    ChangeMode();
    usleep(1000);
  } while (true);
}

void put_value_0121_moldset(void)

{
  byte bVar1;
  uint16_t uVar2;
  uint32_t uVar3;
  uint16_t uVar5;
  uint32_t uVar6;
  uint32_t uVar7;
  uint32_t uVar8;
  uint32_t uVar9;
  uint64_t uVar10;
  uint64_t uVar11;
  DBVALUE DVar12;
  uint8_t auVar13[32];
  uint8_t auVar14[32];
  uint8_t in_stack_00000000[28];
  char test_name[1][30];
  DBVALUE value[1];
  int i;
  uint32_t uVar4;

  i = 0;
  do
  {
    if (CurrentMoldData54_52Count <= i)
    {
      return;
    }
    if (((((DBdata_54_52[i].Address54 != 0) || (DBdata_54_52[i].Precision54 != '\0')) ||
          (DBdata_54_52[i].Address52 != 0)) ||
         (DBdata_54_52[i].Precision52 != '\0')) &&
        (DBdata_54_52[i].Address54 != -1))
    {
      bVar1 = DBdata_54_52[i].Precision54;
      if (bVar1 < 0xc)
      {
        if ((9 < bVar1) || (bVar1 < 2))
        {
        LAB_0004b108:
          test_name[0]._0_4_ = *(uint32_t *)DBdata_54_52[i].Name;
          test_name[0]._4_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 4);
          test_name[0]._8_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 8);
          test_name[0]._12_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0xc);
          test_name[0]._16_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x10);
          test_name[0]._20_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x14);
          test_name[0]._24_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x18);
          test_name[0]._28_2_ = *(uint16_t *)(DBdata_54_52[i].Name + 0x1c);
          uVar5 = value[0].ldata._2_2_;
          uVar2 = *(uint16_t *)(moldset + DBdata_54_52[i].Address54 * 2);
          uVar4 = CONCAT22(uVar5, uVar2);
          uVar7 = value[0]._4_4_;
          uVar11 = CONCAT44(uVar7, uVar4);
          in_stack_00000000 = in_stack_00000000;
          uVar9 = value[0]._8_4_;
          auVar14 = CONCAT284(in_stack_00000000, uVar9);
          DVar12 = (DBVALUE)CONCAT328(auVar14, uVar11);
          compare_get_value(test_name[0], DVar12);
        }
      }
      else
      {
        if (bVar1 == 100)
          goto LAB_0004b108;
        if (bVar1 == 0x65)
        {
          value[0].ldata._2_2_ =
              (uint16_t)((uint) * (uint32_t *)(moldset + DBdata_54_52[i].Address54 * 2) >> 0x10);
          test_name[0]._0_4_ = *(uint32_t *)DBdata_54_52[i].Name;
          test_name[0]._4_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 4);
          test_name[0]._8_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 8);
          test_name[0]._12_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0xc);
          test_name[0]._16_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x10);
          test_name[0]._20_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x14);
          test_name[0]._24_4_ = *(uint32_t *)(DBdata_54_52[i].Name + 0x18);
          test_name[0]._28_2_ = *(uint16_t *)(DBdata_54_52[i].Name + 0x1c);
          uVar6 = value[0]._4_4_;
          uVar3 = *(uint32_t *)(moldset + DBdata_54_52[i].Address54 * 2);
          uVar10 = CONCAT44(uVar6, uVar3);
          in_stack_00000000 = in_stack_00000000;
          uVar8 = value[0]._8_4_;
          auVar13 = CONCAT284(in_stack_00000000, uVar8);
          DVar12 = (DBVALUE)CONCAT328(auVar13, uVar10);
          compare_get_value(test_name[0], DVar12);
        }
      }
    }
    i = i + 1;
  } while (true);
}

void put_value_0021_error(void)

{
  bool bVar1;
  char the_first_flag;
  int errorsame_flag;
  int k;
  int j;
  int i;

  bVar1 = false;
  error.wErrorCode = error.wErrorCode + 1;
  pthread_mutex_lock((pthread_mutex_t *)&mutexlock);
  for (i = 0; i < 3; i = i + 1)
  {
    if ((uint)error.wErrorCode == g_error_code[i])
    {
      bVar1 = true;
      break;
    }
  }
  if (bVar1)
  {
    if (g_error_flag[i] == '\x01')
    {
      if ((99 < error.dateStart.wYear) && (99 < error.dateFixed.wYear))
      {
        memset(&DBdata + (i * 3 + 5) * 0x20, 0, 0x28);
        sprintf((char *)(&DBdata + (i * 3 + 5) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
                error.dateStart.wYear / 100, (uint)error.dateStart.wYear % 100,
                (uint)error.dateStart.bMonth, (uint)error.dateStart.bDay, (uint)error.timeStart.bHour,
                (uint)error.timeStart.bMinute, (uint)error.timeStart.bSecond);
        memset(&DBdata + (i * 3 + 6) * 0x20, 0, 0x28);
        sprintf((char *)(&DBdata + (i * 3 + 6) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
                error.dateFixed.wYear / 100, (uint)error.dateFixed.wYear % 100,
                (uint)error.dateFixed.bMonth, (uint)error.dateFixed.bDay, (uint)error.timeFixed.bHour,
                (uint)error.timeFixed.bMinute, (uint)error.timeFixed.bSecond);
        g_error_flag[i] = '\x02';
      }
    }
    else if (((g_error_flag[i] == '\x02') && (99 < error.dateStart.wYear)) &&
             (99 < error.dateFixed.wYear))
    {
      for (k = 0; k < 0x125; k = k + 1)
      {
        if ((uint)error.wErrorCode == *(uint *)(error_buff + k * 8))
        {
          memset(&DBdata + (i * 3 + 4) * 0x20, 0, 0x28);
          strcpy((char *)(&DBdata + (i * 3 + 4) * 0x20), *(char **)(error_buff + k * 8 + 4));
          break;
        }
      }
      memset(&DBdata + (i * 3 + 5) * 0x20, 0, 0x28);
      sprintf((char *)(&DBdata + (i * 3 + 5) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
              error.dateStart.wYear / 100, (uint)error.dateStart.wYear % 100,
              (uint)error.dateStart.bMonth, (uint)error.dateStart.bDay, (uint)error.timeStart.bHour,
              (uint)error.timeStart.bMinute, (uint)error.timeStart.bSecond);
      memset(&DBdata + (i * 3 + 6) * 0x20, 0, 0x28);
      sprintf((char *)(&DBdata + (i * 3 + 6) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
              error.dateFixed.wYear / 100, (uint)error.dateFixed.wYear % 100,
              (uint)error.dateFixed.bMonth, (uint)error.dateFixed.bDay, (uint)error.timeFixed.bHour,
              (uint)error.timeFixed.bMinute, (uint)error.timeFixed.bSecond);
      g_error_flag[i] = '\x02';
    }
  }
  else if (!bVar1)
  {
    for (k = 0; k < 0x125; k = k + 1)
    {
      if ((uint)error.wErrorCode == *(uint *)(error_buff + k * 8))
      {
        the_first_flag = '\x01';
        break;
      }
    }
    if (the_first_flag == '\x01')
    {
      if (((g_error_flag[0] == '\x01') && (g_error_flag[1] == '\x01')) &&
          (g_error_flag[2] == '\x01'))
      {
        if (roll_flag == '\0')
        {
          g_error_flag[0] = '\x02';
          roll_flag = '\x01';
        }
        else if (roll_flag == '\x01')
        {
          g_error_flag[1] = '\x02';
          roll_flag = '\x02';
        }
        else if (roll_flag == '\x02')
        {
          g_error_flag[2] = '\x02';
          roll_flag = '\0';
        }
      }
      for (j = 0; j < 3; j = j + 1)
      {
        if ((g_error_flag[j] == '\0') || (g_error_flag[j] == '\x02'))
        {
          if ((99 < error.dateStart.wYear) && (99 < error.dateFixed.wYear))
          {
            g_error_code[j] = *(int *)(error_buff + k * 8);
            memset(&DBdata + (j * 3 + 4) * 0x20, 0, 0x28);
            memcpy(&DBdata + (j * 3 + 4) * 0x20, *(void **)(error_buff + k * 8 + 4), 0x1e);
            memset(&DBdata + (j * 3 + 5) * 0x20, 0, 0x28);
            sprintf((char *)(&DBdata + (j * 3 + 5) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
                    error.dateStart.wYear / 100, (uint)error.dateStart.wYear % 100,
                    (uint)error.dateStart.bMonth, (uint)error.dateStart.bDay,
                    (uint)error.timeStart.bHour, (uint)error.timeStart.bMinute,
                    (uint)error.timeStart.bSecond);
            memset(&DBdata + (j * 3 + 6) * 0x20, 0, 0x28);
            sprintf((char *)(&DBdata + (j * 3 + 6) * 0x20), "%02d%02d%02d%02d%02d%02d%02d",
                    error.dateFixed.wYear / 100, (uint)error.dateFixed.wYear % 100,
                    (uint)error.dateFixed.bMonth, (uint)error.dateFixed.bDay,
                    (uint)error.timeFixed.bHour, (uint)error.timeFixed.bMinute,
                    (uint)error.timeFixed.bSecond);
            g_error_flag[j] = '\x01';
          }
          break;
        }
      }
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)&mutexlock);
  return;
}

void put_value_0013_UpdateCommon(void)

{
  bool bVar1;
  uint32_t uVar2;
  tm *ptVar3;
  int iVar4;
  uint uVar5;
  uint32_t uVar6;
  uint64_t uVar7;
  DBVALUE value_00;
  uint8_t auVar8[32];
  uint8_t in_stack_00000000[28];
  time_t tt_local_1;
  time_t tt_local;
  char new_olddata_string[30];
  int str_buff_d[10];
  char str_buff[10];
  char test_name1[3][30];
  DBVALUE value[3];
  ulong dwOldValue;
  ulong dwNewValue;
  uint wOldValue;
  uint wNewValue;
  int precision;
  short sec;
  short min;
  short hour;
  short day;
  short month;
  int year;
  tm *t_local;
  short wensday;
  int i_1;
  int j;
  int precision_flag;
  float precision_i;
  int i;

  // Unresolved local var: int length_old@[???]
  // Unresolved local var: int length_new@[???]
  for (i = 0; i < CurrentMoldData54_52Count; i = i + 1)
  {
    if ((((DBdata_54_52_B_spec[i].Address54 < 0x2100) || (0x212c < DBdata_54_52_B_spec[i].Address54)) && (DBdata_54_52_B_spec[i].Address54 != 0x212e)) &&
        (DBdata_54_52_B_spec[i].Address54 != 0x2130))
    {
      if (DBdata_54_52_B_spec[i].Address54 == modify.wDataID - 0x400)
      {
        memcpy(value, DBdata_54_52_B_spec + i, 0x1e);
        memcpy(test_name1, "tmUpdateContent", 0x14);
        time(&tt_local_1);
        ptVar3 = localtime(&tt_local_1);
        iVar4 = ptVar3->tm_year + 0x76c;
        sprintf(new_olddata_string, "%02d%02d%02d%02d%02d%02d%02d", iVar4 / 100, iVar4 % 100,
                (int)(short)((short)ptVar3->tm_mon + 1), (int)(short)ptVar3->tm_mday,
                (int)(short)ptVar3->tm_hour, (int)(short)ptVar3->tm_min, (int)(short)ptVar3->tm_sec);
        uVar2 = modify.Data.field_0;
        DAT_001598c0._0_1_ = new_olddata_string[0];
        DAT_001598c0._1_1_ = new_olddata_string[1];
        DAT_001598c0._2_1_ = new_olddata_string[2];
        DAT_001598c0._3_1_ = new_olddata_string[3];
        DAT_001598c4._0_1_ = new_olddata_string[4];
        DAT_001598c4._1_1_ = new_olddata_string[5];
        DAT_001598c4._2_1_ = new_olddata_string[6];
        DAT_001598c4._3_1_ = new_olddata_string[7];
        DAT_001598c8._0_1_ = new_olddata_string[8];
        DAT_001598c8._1_1_ = new_olddata_string[9];
        DAT_001598c8._2_1_ = new_olddata_string[10];
        DAT_001598c8._3_1_ = new_olddata_string[0xb];
        DAT_001598cc._0_1_ = new_olddata_string[0xc];
        DAT_001598cc._1_1_ = new_olddata_string[0xd];
        DAT_001598cc._2_1_ = new_olddata_string[0xe];
        DAT_001598cc._3_1_ = new_olddata_string[0xf];
        DAT_001598d0._0_1_ = new_olddata_string[0x10];
        DAT_001598d0._1_1_ = new_olddata_string[0x11];
        DAT_001598d0._2_1_ = new_olddata_string[0x12];
        DAT_001598d0._3_1_ = new_olddata_string[0x13];
        DAT_001598d4._0_1_ = new_olddata_string[0x14];
        DAT_001598d4._1_1_ = new_olddata_string[0x15];
        DAT_001598d4._2_1_ = new_olddata_string[0x16];
        DAT_001598d4._3_1_ = new_olddata_string[0x17];
        DAT_001598d8._0_1_ = new_olddata_string[0x18];
        DAT_001598d8._1_1_ = new_olddata_string[0x19];
        DAT_001598d8._2_1_ = new_olddata_string[0x1a];
        DAT_001598d8._3_1_ = new_olddata_string[0x1b];
        DAT_001598dc = (uint16_t)stack0xfffffea4;
        uVar5 = (uint)(byte)DBdata_54_52_B_spec[i].Precision54;
        if (uVar5 == 10)
        {
          precision_i = 10.0;
        }
        else if (10 < uVar5)
        {
          if (uVar5 == 0xb)
          {
            if (g_SPEED_Precious == 999)
            {
              precision_i = 10.0;
            }
            else
            {
              precision_i = 1.0;
            }
          }
          else if (uVar5 - 100 < 2)
          {
            precision_i = 100.0;
          }
        }
        if (((uVar5 == 0) || (precision_i == 1.0)) || (uVar5 == 1))
        {
          bVar1 = true;
        }
        else
        {
          bVar1 = false;
        }
        if (modify.wDataType == 0)
        {
          uVar5 = modify.Data.field_1.dwOldValue >> 0x10;
          if (bVar1)
          {
            sprintf(str_buff, "%d", modify.Data.field_1.dwOldValue & 0xffff);
            memcpy(value + 1, str_buff, 10);
            memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
            sprintf(str_buff, "%d", uVar5);
            memcpy(value + 2, str_buff, 10);
            memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
          }
          else
          {
            sprintf(str_buff, "%.2f",
                    (double)((float)(modify.Data.field_1.dwOldValue & 0xffff) / precision_i));
            memcpy(value + 1, str_buff, 10);
            memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
            sprintf(str_buff, "%.2f", (double)((float)uVar5 / precision_i));
            memcpy(value + 2, str_buff, 10);
            memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
          }
          for (j = 0; j < 0x1fe; j = j + 1)
          {
            iVar4 = strcmp(DBdata_54_52_B_spec[i].Name, *(char **)(&DAT_001594ec + j * 0x40));
            if ((iVar4 == 0) && (uVar5 != 0xffff))
            {
              (&DBdata)[j * 0x20] = SUB42(uVar2, 2);
            }
          }
        }
        uVar2 = modify.Data.field_1.dwNewValue;
        if (modify.wDataType == 1)
        {
          if (bVar1)
          {
            sprintf(str_buff, "%d", modify.Data.field_1.dwOldValue);
            memcpy(value + 1, str_buff, 10);
            memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
            sprintf(str_buff, "%d", uVar2);
            memcpy(value + 2, str_buff, 10);
            memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
          }
          else
          {
            sprintf(str_buff, "%.2f", (double)((float)modify.Data._0_4_ / precision_i));
            memcpy(value + 1, str_buff, 10);
            memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
            sprintf(str_buff, "%.2f", (double)((float)(uint)uVar2 / precision_i));
            memcpy(value + 2, str_buff, 10);
            memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
          }
          for (j = 0; j < 0x1fe; j = j + 1)
          {
            iVar4 = strcmp(DBdata_54_52_B_spec[i].Name, *(char **)(&DAT_001594ec + j * 0x40));
            if ((iVar4 == 0) && (uVar2 != 0xffff))
            {
              (&DBdata)[j * 0x20] = (short)uVar2;
            }
          }
        }
      }
    }
    else if (DBdata_54_52_B_spec[i].Address54 == (uint)modify.wDataID)
    {
      memcpy(value, DBdata_54_52_B_spec + i, 0x1e);
      memcpy(test_name1, "tmUpdateContent", 0x14);
      time(&tt_local);
      ptVar3 = localtime(&tt_local);
      iVar4 = ptVar3->tm_year + 0x76c;
      sprintf(new_olddata_string, "%02d%02d%02d%02d%02d%02d%02d", iVar4 / 100, iVar4 % 100,
              (int)(short)((short)ptVar3->tm_mon + 1), (int)(short)ptVar3->tm_mday,
              (int)(short)ptVar3->tm_hour, (int)(short)ptVar3->tm_min, (int)(short)ptVar3->tm_sec);
      uVar2 = modify.Data.field_0;
      DAT_001598c0._0_1_ = new_olddata_string[0];
      DAT_001598c0._1_1_ = new_olddata_string[1];
      DAT_001598c0._2_1_ = new_olddata_string[2];
      DAT_001598c0._3_1_ = new_olddata_string[3];
      DAT_001598c4._0_1_ = new_olddata_string[4];
      DAT_001598c4._1_1_ = new_olddata_string[5];
      DAT_001598c4._2_1_ = new_olddata_string[6];
      DAT_001598c4._3_1_ = new_olddata_string[7];
      DAT_001598c8._0_1_ = new_olddata_string[8];
      DAT_001598c8._1_1_ = new_olddata_string[9];
      DAT_001598c8._2_1_ = new_olddata_string[10];
      DAT_001598c8._3_1_ = new_olddata_string[0xb];
      DAT_001598cc._0_1_ = new_olddata_string[0xc];
      DAT_001598cc._1_1_ = new_olddata_string[0xd];
      DAT_001598cc._2_1_ = new_olddata_string[0xe];
      DAT_001598cc._3_1_ = new_olddata_string[0xf];
      DAT_001598d0._0_1_ = new_olddata_string[0x10];
      DAT_001598d0._1_1_ = new_olddata_string[0x11];
      DAT_001598d0._2_1_ = new_olddata_string[0x12];
      DAT_001598d0._3_1_ = new_olddata_string[0x13];
      DAT_001598d4._0_1_ = new_olddata_string[0x14];
      DAT_001598d4._1_1_ = new_olddata_string[0x15];
      DAT_001598d4._2_1_ = new_olddata_string[0x16];
      DAT_001598d4._3_1_ = new_olddata_string[0x17];
      DAT_001598d8._0_1_ = new_olddata_string[0x18];
      DAT_001598d8._1_1_ = new_olddata_string[0x19];
      DAT_001598d8._2_1_ = new_olddata_string[0x1a];
      DAT_001598d8._3_1_ = new_olddata_string[0x1b];
      DAT_001598dc = (uint16_t)stack0xfffffea4;
      uVar5 = (uint)(byte)DBdata_54_52_B_spec[i].Precision54;
      if (uVar5 == 10)
      {
        precision_i = 10.0;
      }
      else if (10 < uVar5)
      {
        if (uVar5 == 0xb)
        {
          if (g_SPEED_Precious == 999)
          {
            precision_i = 10.0;
          }
          else
          {
            precision_i = 1.0;
          }
        }
        else if (uVar5 - 100 < 2)
        {
          precision_i = 100.0;
        }
      }
      if (((uVar5 == 0) || (precision_i == 1.0)) || (uVar5 == 1))
      {
        bVar1 = true;
      }
      else
      {
        bVar1 = false;
      }
      if (modify.wDataType == 0)
      {
        uVar5 = modify.Data.field_1.dwOldValue >> 0x10;
        if (bVar1)
        {
          sprintf(str_buff, "%d", modify.Data.field_1.dwOldValue & 0xffff);
          memcpy(value + 1, str_buff, 10);
          memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
          sprintf(str_buff, "%d", uVar5);
          memcpy(value + 2, str_buff, 10);
          memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
        }
        else
        {
          sprintf(str_buff, "%.2f",
                  (double)((float)(modify.Data.field_1.dwOldValue & 0xffff) / precision_i));
          memcpy(value + 1, str_buff, 10);
          memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
          sprintf(str_buff, "%.2f", (double)((float)uVar5 / precision_i));
          memcpy(value + 2, str_buff, 10);
          memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
        }
        for (j = 0; j < 0x1fe; j = j + 1)
        {
          iVar4 = strcmp(DBdata_54_52_B_spec[i].Name, *(char **)(&DAT_001594ec + j * 0x40));
          if ((iVar4 == 0) && (uVar5 != 0xffff))
          {
            (&DBdata)[j * 0x20] = SUB42(uVar2, 2);
          }
        }
      }
      uVar2 = modify.Data.field_1.dwNewValue;
      if (modify.wDataType == 1)
      {
        if (bVar1)
        {
          sprintf(str_buff, "%d", modify.Data.field_1.dwOldValue);
          memcpy(value + 1, str_buff, 10);
          memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
          sprintf(str_buff, "%d", uVar2);
          memcpy(value + 2, str_buff, 10);
          memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
        }
        else
        {
          sprintf(str_buff, "%.2f", (double)((float)modify.Data._0_4_ / precision_i));
          memcpy(value + 1, str_buff, 10);
          memcpy(test_name1 + 1, "tmUpdateOld", 0x14);
          sprintf(str_buff, "%.2f", (double)((float)(uint)uVar2 / precision_i));
          memcpy(value + 2, str_buff, 10);
          memcpy(test_name1 + 2, "tmUpdateNew", 0x14);
        }
        for (j = 0; j < 0x1fe; j = j + 1)
        {
          iVar4 = strcmp(DBdata_54_52_B_spec[i].Name, *(char **)(&DAT_001594ec + j * 0x40));
          if ((iVar4 == 0) && (uVar2 != 0xffff))
          {
            (&DBdata)[j * 0x20] = (short)uVar2;
          }
        }
      }
    }
  }
  for (i_1 = 0; i_1 < 3; i_1 = i_1 + 1)
  {
    uVar6 = *(uint32_t *)((int)value + i_1 * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar8 = CONCAT284(in_stack_00000000, uVar6);
    uVar7 = *(uint64_t *)(value + i_1);
    value_00 = (DBVALUE)CONCAT328(auVar8, uVar7);
    compare_get_value(test_name1[i_1], value_00);
  }
  return;
}

void put_value_0026_energy(void)

{
  uint32_t uVar1;
  uint64_t uVar2;
  DBVALUE value_00;
  uint8_t auVar3[32];
  uint8_t in_stack_00000000[28];
  char test_name1[1][30];
  DBVALUE value[1];
  int i;

  value[0].ldata = energy.tmTotalEnergyConsumption;
  builtin_strncpy(test_name1[0], "tmTotalEnergyConsumption", 0x19);
  test_name1[0][0x19] = '\0';
  test_name1[0][0x1a] = '\0';
  test_name1[0][0x1b] = '\0';
  test_name1[0][0x1c] = 't';
  test_name1[0][0x1d] = 'm';
  for (i = 0; i < 1; i = i + 1)
  {
    uVar1 = *(uint32_t *)((int)value + i * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar3 = CONCAT284(in_stack_00000000, uVar1);
    uVar2 = *(uint64_t *)(value + i);
    value_00 = (DBVALUE)CONCAT328(auVar3, uVar2);
    compare_get_value(test_name1[i], value_00);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void put_value_0010_temper_set(void)

{
  uint32_t uVar1;
  uint64_t uVar2;
  DBVALUE value_00;
  uint8_t auVar3[32];
  uint8_t in_stack_00000000[28];
  char test_name1[18][30];
  DBVALUE value[18];
  int i;

  value[0].sdata = temper.wTempSet[0];
  memcpy(test_name1, "tmTemp1_Set", 0x14);
  value[1].sdata = temper.wTempSet[1];
  memcpy(test_name1 + 1, "tmTemp2_Set", 0x14);
  value[2].sdata = temper.wTempSet[2];
  memcpy(test_name1 + 2, "tmTemp3_Set", 0x14);
  value[3].sdata = temper.wTempSet[3];
  memcpy(test_name1 + 3, "tmTemp4_Set", 0x14);
  value[4].sdata = temper.wTempSet[4];
  memcpy(test_name1 + 4, "tmTemp5_Set", 0x14);
  value[5].sdata = temper.wTempSet[5];
  memcpy(test_name1 + 5, "tmTemp6_Set", 0x14);
  value[6].sdata = temper.wTempSet[6];
  memcpy(test_name1 + 6, "tmTemp7_Set", 0x14);
  value[7].sdata = temper.wTempSet[7];
  memcpy(test_name1 + 7, "tmTemp8_Set", 0x14);
  value[8].sdata = temper.wTempSet[8];
  memcpy(test_name1 + 8, "tmTemp9_Set", 0x14);
  value[9].sdata = temper.wTempSet[10];
  memcpy(test_name1 + 9, "tmTemp1_SetB", 0x14);
  value[10].sdata = temper.wTempSet[0xb];
  memcpy(test_name1 + 10, "tmTemp2_SetB", 0x14);
  value[0xb].sdata = temper.wTempSet[0xc];
  memcpy(test_name1 + 0xb, "tmTemp3_SetB", 0x14);
  value[0xc].sdata = temper.wTempSet[0xd];
  memcpy(test_name1 + 0xc, "tmTemp4_SetB", 0x14);
  value[0xd].sdata = temper.wTempSet[0xe];
  memcpy(test_name1 + 0xd, "tmTemp5_SetB", 0x14);
  value[0xe].sdata = temper.wTempSet[0xf];
  memcpy(test_name1 + 0xe, "tmTemp6_SetB", 0x14);
  value[0xf].sdata = temper.wTempSet[0x10];
  memcpy(test_name1 + 0xf, "tmTemp7_SetB", 0x14);
  value[0x10].sdata = temper.wTempSet[0x11];
  memcpy(test_name1 + 0x10, "tmTemp8_SetB", 0x14);
  value[0x11].sdata = temper.wTempSet[0x12];
  memcpy(test_name1 + 0x11, "tmTemp9_SetB", 0x14);
  for (i = 0; i < 0x12; i = i + 1)
  {
    uVar1 = *(uint32_t *)((int)value + i * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar3 = CONCAT284(in_stack_00000000, uVar1);
    uVar2 = *(uint64_t *)(value + i);
    value_00 = (DBVALUE)CONCAT328(auVar3, uVar2);
    compare_get_value(test_name1[i], value_00);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void put_value_0010_temper_current(void)

{
  uint32_t uVar1;
  uint64_t uVar2;
  DBVALUE value_00;
  uint8_t auVar3[32];
  uint8_t in_stack_00000000[28];
  char test_name1[19][30];
  DBVALUE value[19];
  int i;

  value[0].sdata = temper.wTempReal[0];
  memcpy(test_name1, "tmTemp1_Current", 0x14);
  value[1].sdata = temper.wTempReal[1];
  memcpy(test_name1 + 1, "tmTemp2_Current", 0x14);
  value[2].sdata = temper.wTempReal[2];
  memcpy(test_name1 + 2, "tmTemp3_Current", 0x14);
  value[3].sdata = temper.wTempReal[3];
  memcpy(test_name1 + 3, "tmTemp4_Current", 0x14);
  value[4].sdata = temper.wTempReal[4];
  memcpy(test_name1 + 4, "tmTemp5_Current", 0x14);
  value[5].sdata = temper.wTempReal[5];
  memcpy(test_name1 + 5, "tmTemp6_Current", 0x14);
  value[6].sdata = temper.wTempReal[6];
  memcpy(test_name1 + 6, "tmTemp7_Current", 0x14);
  value[7].sdata = temper.wTempReal[7];
  memcpy(test_name1 + 7, "tmTemp8_Current", 0x14);
  value[8].sdata = temper.wTempReal[8];
  memcpy(test_name1 + 8, "tmTemp9_Current", 0x14);
  value[9].sdata = temper.wTempReal[9];
  memcpy(test_name1 + 9, "tmTempOil_Current", 0x14);
  value[10].sdata = temper.wTempReal[10];
  memcpy(test_name1 + 10, "tmTemp1_CurrentB", 0x14);
  value[0xb].sdata = temper.wTempReal[0xb];
  memcpy(test_name1 + 0xb, "tmTemp2_CurrentB", 0x14);
  value[0xc].sdata = temper.wTempReal[0xc];
  memcpy(test_name1 + 0xc, "tmTemp3_CurrentB", 0x14);
  value[0xd].sdata = temper.wTempReal[0xd];
  memcpy(test_name1 + 0xd, "tmTemp4_CurrentB", 0x14);
  value[0xe].sdata = temper.wTempReal[0xe];
  memcpy(test_name1 + 0xe, "tmTemp5_CurrentB", 0x14);
  value[0xf].sdata = temper.wTempReal[0xf];
  memcpy(test_name1 + 0xf, "tmTemp6_CurrentB", 0x14);
  value[0x10].sdata = temper.wTempReal[0x10];
  memcpy(test_name1 + 0x10, "tmTemp7_CurrentB", 0x14);
  value[0x11].sdata = temper.wTempReal[0x11];
  memcpy(test_name1 + 0x11, "tmTemp8_CurrentB", 0x14);
  value[0x12].sdata = temper.wTempReal[0x12];
  memcpy(test_name1 + 0x12, "tmTemp9_CurrentB", 0x14);
  for (i = 0; i < 0x13; i = i + 1)
  {
    uVar1 = *(uint32_t *)((int)value + i * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar3 = CONCAT284(in_stack_00000000, uVar1);
    uVar2 = *(uint64_t *)(value + i);
    value_00 = (DBVALUE)CONCAT328(auVar3, uVar2);
    compare_get_value(test_name1[i], value_00);
  }
  return;
}

void put_value_0040_instant(void)

{
  uint32_t uVar1;
  double dVar2;
  uint64_t uVar3;
  DBVALUE value;
  uint8_t auVar4[32];
  uint8_t in_stack_00000000[28];
  uint32_t u32Temp;
  int alarm;
  char test_name[15][30];
  DBVALUE value_0[15];
  int i;

  // Unresolved local var: float fTemp@[???]
  memset(value_0, 0, 0x208);
  memset(value_0, 0, 0x28);
  memcpy(value_0, operstate.wTEST, 0xe);
  memcpy(test_name, "tmCraftID", 0x14);
  memset(value_0 + 1, 0, 0x28);
  memcpy(value_0 + 1, operstate.wTEST + 0x14, 6);
  memcpy(test_name + 1, "tmMaterial", 0x14);
  memcpy(value_0 + 2, operstate.wTEST + 0x1a, 6);
  memcpy(test_name + 2, "tmColor", 0x14);
  value_0[3]._0_1_ = operstate.wTEST[0x20];
  value_0[3]._1_1_ = operstate.wTEST[0x21];
  memcpy(test_name + 3, "tmMoldCavity", 0x14);
  g_OperateMode_i = 0;
  while ((g_OperateMode_i < 0x10 &&
          (dVar2 = pow(2.0, (double)(longlong)g_OperateMode_i), dVar2 <= (double)operstate.wOperState)))
  {
    g_OperateMode_i = g_OperateMode_i + 1;
  }
  if (g_OperateMode_i < 6)
  {
    if (g_OperateMode_i == 0)
    {
      operstate.wOperState = 0;
    }
    else
    {
      operstate.wOperState = (short)g_OperateMode_i - 1;
    }
  }
  else
  {
    operstate.wOperState = 5;
  }
  value_0[4].sdata = operstate.wOperState;
  memcpy(test_name + 4, "tmOperateMode", 0x14);
  operstate.dwShotCountCurrent =
      __aeabi_uidiv(operstate.dwShotCountCurrent, (uint)(ushort)value_0[3]._0_2_);
  value_0[5]._0_4_ = operstate.dwShotCountCurrent;
  memcpy(test_name + 5, "tmShotCount", 0x14);
  if (operstate.wHeatState != 0)
  {
    operstate.wHeatState = 1;
  }
  if (operstate.wHeatState == 0)
  {
    operstate.wHeatState = 0;
  }
  if (operstate.wMotorState != 0)
  {
    operstate.wMotorState = 1;
  }
  if (operstate.wMotorState == 0)
  {
    operstate.wMotorState = 0;
  }
  value_0[6].sdata = operstate.wHeatState;
  memcpy(test_name + 6, "tmHeatState", 0x14);
  value_0[7].sdata = operstate.wMotorState;
  memcpy(test_name + 7, "tmMotorState", 0x14);
  if (operstate.wErrorState == 0xffff)
  {
    g_wErrorState = 0;
    if (g_error_state_flag == '\x01')
    {
      g_error_end_flag = '\x01';
      g_error_state_flag = '\0';
    }
  }
  else
  {
    g_wErrorState = 1;
    g_error_state_flag = '\x01';
  }
  value_0[8].sdata = g_wErrorState;
  memcpy(test_name + 8, "tmAlarmState", 0x14);
  if (value_0[8].sdata == 0)
  {
    value_0[9].sdata = 0;
    memcpy(test_name + 9, "tmAlarmID", 0x14);
  }
  value_0[10]._0_4_ = operstate.tmPlanCount - DAT_00159c00;
  memcpy(test_name + 10, "tmPlanCount", 0x14);
  value_0[0xb].sdata = operstate.wtmLotNumber;
  memcpy(test_name + 0xb, "tmLotNumber", 0x14);
  value_0[0xc].sdata = operstate.wtmBadShotCount;
  memcpy(test_name + 0xc, "tmBadShotCount", 0x14);
  value_0[0xe].sdata = operstate.wPowerRatio;
  memcpy(test_name + 0xe, "tmPowerConsumptionRatio", 0x17);
  value_0[0xd].ldata = operstate.dwTotalElectricity;
  memcpy(test_name + 0xd, "tmPowerConsumption", 0x14);
  for (i = 0; i < 0xf; i = i + 1)
  {
    uVar1 = *(uint32_t *)((int)value_0 + i * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar4 = CONCAT284(in_stack_00000000, uVar1);
    uVar3 = *(uint64_t *)(value_0 + i);
    value = (DBVALUE)CONCAT328(auVar4, uVar3);
    compare_get_value(test_name[i], value);
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void put_value_0011_monitor(void)

{
  DWORD_T DVar1;
  DWORD_T DVar2;
  size_t sVar3;
  uint32_t uVar4;
  uint64_t uVar5;
  DBVALUE value_00;
  uint8_t auVar6[32];
  uint8_t in_stack_00000000[28];
  char test_name[48][30];
  DBVALUE value[48];
  char string[13];
  ulong tmbcCoolTime_Value;
  ulong ShiftNo_Value;
  ulong MaterialLotB_Value[3];
  ulong MaterialLotA_Value[3];
  ulong MaterialSpec_Value[3];
  ulong Bar2_Value[3];
  ulong Bar1_Value[3];
  BCCode tmbcCoolTime;
  BCCode ShiftNo;
  BCCode MaterialLotB[3];
  BCCode MaterialLotA[3];
  BCCode MaterialSpec[3];
  BCCode Bar2[3];
  BCCode Bar1[3];
  int i;

  string[0] = '\0';
  string[1] = '\0';
  string[2] = '\0';
  string[3] = '\0';
  string[4] = '\0';
  string[5] = '\0';
  string[6] = '\0';
  string[7] = '\0';
  string[8] = '\0';
  string[9] = '\0';
  string[10] = '\0';
  string[0xb] = '\0';
  string[0xc] = '\0';
  memset(Bar1, 0, 0xc);
  memset(Bar2, 0, 0xc);
  memset(MaterialSpec, 0, 0xc);
  memset(MaterialLotA, 0, 0xc);
  memset(MaterialLotB, 0, 0xc);
  value[0].ldata = monitor.dwCycletime;
  memcpy(test_name, "tmCycleTime", 0x14);
  value[1].ldata = monitor.dwInjecttime;
  memcpy(test_name + 1, "tmInjTime", 0x14);
  value[2].ldata = monitor.tmTurnTime;
  memcpy(test_name + 2, "tmTurnTime", 0x14);
  value[3].ldata = monitor.tmChargeTime;
  memcpy(test_name + 3, "tmChargeTime", 0x14);
  value[4].sdata = monitor.tmClpClsTime;
  memcpy(test_name + 4, "tmClpClsTime", 0x14);
  value[5].sdata = monitor.tmClpClsProtectTime;
  builtin_strncpy(test_name[5], "tmClpClsProtectTime", 0x14);
  builtin_strncpy((char *)((int)(test_name + 5) + 0x14), "tmClpClsHi", 10);
  value[6].sdata = monitor.tmClpClsHighTime;
  memcpy(test_name + 6, "tmClpClsHighTime", 0x14);
  value[7].sdata = monitor.tmClpOpnPosi;
  memcpy(test_name + 7, "tmClpOpnPosi", 0x14);
  value[8].sdata = monitor.tmClpOpnTime;
  memcpy(test_name + 8, "tmClpOpnTime", 0x14);
  value[9].sdata = monitor.tmTurnPress;
  memcpy(test_name + 9, "tmTurnPress", 0x14);
  value[10].sdata = monitor.tmInjStartPosi;
  memcpy(test_name + 10, "tmInjStartPosi", 0x14);
  value[0xb].sdata = monitor.tmTurnPosi;
  memcpy(test_name + 0xb, "tmTurnPosi", 0x14);
  value[0xc].sdata = monitor.tmInjEndPosi;
  memcpy(test_name + 0xc, "tmInjEndPosi", 0x14);
  value[0xd].sdata = monitor.tmInjEnd;
  memcpy(test_name + 0xd, "tmInjMoni", 0x14);
  value[0xf].sdata = monitor.tmChargeRPM;
  memcpy(test_name + 0xf, "tmChargeRPM", 0x14);
  value[0x10].sdata = monitor.tmInjBackTime;
  builtin_strncpy(test_name[0x10], "tmInjBackTime", 0xe);
  test_name[0x10][0xe] = '\0';
  test_name[0x10][0xf] = '\0';
  test_name[0x10][0x10] = 't';
  test_name[0x10][0x11] = 'm';
  test_name[0x10][0x12] = 'E';
  test_name[0x10][0x13] = 'j';
  test_name[0x10][0x14] = 'e';
  test_name[0x10][0x15] = 'c';
  test_name[0x10][0x16] = 't';
  test_name[0x10][0x17] = 'T';
  test_name[0x10][0x18] = 'i';
  test_name[0x10][0x19] = 'm';
  test_name[0x10][0x1a] = 'e';
  test_name[0x10][0x1b] = '\0';
  test_name[0x10][0x1c] = 't';
  test_name[0x10][0x1d] = 'm';
  value[0x11].sdata = monitor.tmEjectTime;
  memcpy(test_name + 0x11, "tmEjectTime", 0x14);
  value[0x12].sdata = monitor.tmClpClsHighPres;
  memcpy(test_name + 0x12, "tmClpClsHighPres", 0x14);
  value[0x13].sdata = monitor.tmInjHighPress;
  builtin_strncpy(test_name[0x13], "tmInjMaxPress", 0xe);
  test_name[0x13][0xe] = '\0';
  test_name[0x13][0xf] = '\0';
  test_name[0x13][0x10] = 't';
  test_name[0x13][0x11] = 'm';
  test_name[0x13][0x12] = 'C';
  test_name[0x13][0x13] = 'h';
  test_name[0x13][0x14] = 'a';
  test_name[0x13][0x15] = 'r';
  test_name[0x13][0x16] = 'g';
  test_name[0x13][0x17] = 'e';
  test_name[0x13][0x18] = 'M';
  test_name[0x13][0x19] = 'a';
  test_name[0x13][0x1a] = 'x';
  test_name[0x13][0x1b] = 'P';
  test_name[0x13][0x1c] = 'r';
  test_name[0x13][0x1d] = 'e';
  value[0x14].sdata = monitor.tmChargeHighPress;
  memcpy(test_name + 0x14, "tmChargeMaxPress", 0x14);
  value[0x15].sdata = monitor.tmEjectAdvTime;
  memcpy(test_name + 0x15, "tmEjectAdvTime", 0x14);
  value[0x16].sdata = monitor.tmEjectRetTime;
  builtin_strncpy(test_name[0x16], "tmEjectRetTime", 0xf);
  test_name[0x16][0xf] = '\0';
  test_name[0x16][0x10] = 't';
  test_name[0x16][0x11] = 'm';
  test_name[0x16][0x12] = 'I';
  test_name[0x16][0x13] = 'n';
  test_name[0x16][0x14] = 'j';
  test_name[0x16][0x15] = 'M';
  test_name[0x16][0x16] = 'a';
  test_name[0x16][0x17] = 'x';
  test_name[0x16][0x18] = 'S';
  test_name[0x16][0x19] = 'p';
  test_name[0x16][0x1a] = 'e';
  test_name[0x16][0x1b] = 'e';
  test_name[0x16][0x1c] = 'd';
  test_name[0x16][0x1d] = '\0';
  value[0x17].sdata = monitor.tmInjMaxSpeed;
  memcpy(test_name + 0x17, "tmInjMaxSpeed", 0x14);
  value[0x18].ldata = monitor.tmFetchTime;
  memcpy(test_name + 0x18, "tmFetchTime", 0x14);
  value[0x19].ldata = monitor.tmInjTimeB;
  memcpy(test_name + 0x19, "tmInjTimeB", 0x14);
  value[0x1a].ldata = monitor.tmTurnTimeB;
  builtin_strncpy(test_name[0x1a], "tmTurnTimeB", 0xc);
  builtin_strncpy((char *)((int)(test_name + 0x1a) + 0xc), "tmChargeTimeB", 0xe);
  test_name[0x1a][0x1a] = '\0';
  test_name[0x1a][0x1b] = '\0';
  test_name[0x1a][0x1c] = 't';
  test_name[0x1a][0x1d] = 'm';
  value[0x1b].sdata = (ushort)monitor.tmChargeTimeB;
  memcpy(test_name + 0x1b, "tmChargeTimeB", 0x14);
  value[0x1c].sdata = monitor.tmTurnPressB;
  memcpy(test_name + 0x1c, "tmTurnPressB", 0x14);
  value[0x1d].sdata = monitor.tmInjStartPosiB;
  builtin_strncpy(test_name[0x1d], "tmInjStartPosiB", 0x10);
  builtin_strncpy((char *)((int)(test_name + 0x1d) + 0x10), "tmTurnPosiB", 0xc);
  test_name[0x1d][0x1c] = 't';
  test_name[0x1d][0x1d] = 'm';
  value[0x1e].sdata = monitor.tmTurnPosiB;
  memcpy(test_name + 0x1e, "tmTurnPosiB", 0x14);
  value[0x1f].sdata = monitor.tmInjEndPosiB;
  builtin_strncpy(test_name[0x1f], "tmInjEndPosiB", 0xe);
  test_name[0x1f][0xe] = '\0';
  test_name[0x1f][0xf] = '\0';
  test_name[0x1f][0x10] = 't';
  test_name[0x1f][0x11] = 'm';
  test_name[0x1f][0x12] = 'I';
  test_name[0x1f][0x13] = 'n';
  test_name[0x1f][0x14] = 'j';
  test_name[0x1f][0x15] = 'E';
  test_name[0x1f][0x16] = 'n';
  test_name[0x1f][0x17] = 'd';
  test_name[0x1f][0x18] = 'B';
  test_name[0x1f][0x19] = '\0';
  test_name[0x1f][0x1a] = '\0';
  test_name[0x1f][0x1b] = '\0';
  test_name[0x1f][0x1c] = 't';
  test_name[0x1f][0x1d] = 'm';
  value[0x20].sdata = monitor.tmInjEndB;
  memcpy(test_name + 0x20, "tmInjEndB", 0x14);
  value[0x21].sdata = monitor.tmChargeRPMB;
  memcpy(test_name + 0x21, "tmChargeRPMB", 0x14);
  value[0x22].sdata = monitor.tmInjBackTimeB;
  builtin_strncpy(test_name[0x22], "tmInjBackTimeB", 0xf);
  test_name[0x22][0xf] = '\0';
  test_name[0x22][0x10] = 't';
  test_name[0x22][0x11] = 'm';
  test_name[0x22][0x12] = 'E';
  test_name[0x22][0x13] = 'j';
  test_name[0x22][0x14] = 'e';
  test_name[0x22][0x15] = 'c';
  test_name[0x22][0x16] = 't';
  test_name[0x22][0x17] = 'T';
  test_name[0x22][0x18] = 'i';
  test_name[0x22][0x19] = 'm';
  test_name[0x22][0x1a] = 'e';
  test_name[0x22][0x1b] = 'B';
  test_name[0x22][0x1c] = '\0';
  test_name[0x22][0x1d] = '\0';
  value[0x23].sdata = monitor.tmEjectTimeB;
  memcpy(test_name + 0x23, "tmEjectTimeB", 0x14);
  value[0x24].sdata = monitor.tmInjMaxPressB;
  builtin_strncpy(test_name[0x24], "tmInjMaxPressB", 0xf);
  test_name[0x24][0xf] = '\0';
  test_name[0x24][0x10] = 't';
  test_name[0x24][0x11] = 'm';
  test_name[0x24][0x12] = 'C';
  test_name[0x24][0x13] = 'h';
  test_name[0x24][0x14] = 'a';
  test_name[0x24][0x15] = 'r';
  test_name[0x24][0x16] = 'g';
  test_name[0x24][0x17] = 'e';
  test_name[0x24][0x18] = 'M';
  test_name[0x24][0x19] = 'a';
  test_name[0x24][0x1a] = 'x';
  test_name[0x24][0x1b] = 'P';
  test_name[0x24][0x1c] = 'r';
  test_name[0x24][0x1d] = 'e';
  value[0x25].sdata = monitor.tmChargeMaxPressB;
  memcpy(test_name + 0x25, "tmChargeMaxPressB", 0x14);
  if (g_machine_type == 0x2001)
  {
    memset(string, 0, 0xd);
    Bar1[0].dwValue = monitor.tmbcBarCode1_1;
    memset(string, 0, 4);
    string._0_4_ = Bar1[0];
    Bar1[1].dwValue = monitor.tmbcBarCode1_2;
    memset(string + 4, 0, 4);
    string._4_4_ = Bar1[1];
    Bar1[2].dwValue = monitor.tmbcBarCode1_3;
    memset(string + 8, 0, 4);
    string._8_4_ = Bar1[2];
    memset(value + 0x26, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x26, string, sVar3);
    memcpy(test_name + 0x26, "tmbcBarCode1", 0x14);
    memset(string, 0, 0xd);
    Bar2[0].dwValue = monitor.tmbcBarCode2_1;
    memset(string, 0, 4);
    string._0_4_ = Bar2[0];
    Bar2[1].dwValue = monitor.tmbcBarCode2_2;
    memset(string + 4, 0, 4);
    string._4_4_ = Bar2[1];
    Bar2[2].dwValue = monitor.tmbcBarCode2_3;
    memset(string + 8, 0, 4);
    string._8_4_ = Bar2[2];
    memset(value + 0x27, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x27, string, sVar3);
    memcpy(test_name + 0x27, "tmbcBarCode2", 0x14);
    memset(string, 0, 0xd);
    MaterialSpec[0].dwValue = monitor.tmbcMaterialSpec_1;
    memset(string, 0, 4);
    string._0_4_ = MaterialSpec[0];
    MaterialSpec[1].dwValue = monitor.tmbcMaterialSpec_2;
    memset(string + 4, 0, 4);
    string._4_4_ = MaterialSpec[1];
    MaterialSpec[2].dwValue = monitor.tmbcMaterialSpec_3;
    memset(string + 8, 0, 4);
    string._8_4_ = MaterialSpec[2];
    memset(value + 0x28, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x28, string, sVar3);
    memcpy(test_name + 0x28, "tmbcMaterialSpec", 0x14);
    memset(string, 0, 0xd);
    MaterialLotA[0].dwValue = monitor.tmbcMaterialLotA_1;
    memset(string, 0, 4);
    string._0_4_ = MaterialLotA[0];
    MaterialLotA[1].dwValue = monitor.tmbcMaterialLotA_2;
    memset(string + 4, 0, 4);
    string._4_4_ = MaterialLotA[1];
    MaterialLotA[2].dwValue = monitor.tmbcMaterialLotA_3;
    memset(string + 8, 0, 4);
    string._8_4_ = MaterialLotA[2];
    memset(value + 0x29, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x29, string, sVar3);
    memcpy(test_name + 0x29, "tmbcMaterialLotA", 0x14);
    memset(string, 0, 0xd);
    MaterialLotB[0].dwValue = monitor.tmbcMaterialLotB_1;
    memset(string, 0, 4);
    string._0_4_ = MaterialLotB[0];
    MaterialLotB[1].dwValue = monitor.tmbcMaterialLotB_2;
    memset(string + 4, 0, 4);
    string._4_4_ = MaterialLotB[1];
    MaterialLotB[2].dwValue = monitor.tmbcMaterialLotB_3;
    memset(string + 8, 0, 4);
    string._8_4_ = MaterialLotB[2];
    memset(value + 0x2a, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x2a, string, sVar3);
    memcpy(test_name + 0x2a, "tmbcMaterialLotB", 0x14);
    memset(string, 0, 0xd);
    DVar1 = monitor.tmbcShiftNo;
    memset(string, 0, 4);
    DVar2 = monitor.tmbcShiftNo;
    monitor.tmbcShiftNo._0_1_ = (uint8_t)DVar1;
    monitor.tmbcShiftNo._1_1_ = SUB41(DVar1, 1);
    monitor.tmbcShiftNo._2_1_ = SUB41(DVar1, 2);
    monitor.tmbcShiftNo._3_1_ = SUB41(DVar1, 3);
    string[0] = (uint8_t)monitor.tmbcShiftNo;
    string[1] = monitor.tmbcShiftNo._1_1_;
    string[2] = monitor.tmbcShiftNo._2_1_;
    string[3] = monitor.tmbcShiftNo._3_1_;
    monitor.tmbcShiftNo = DVar2;
    memset(value + 0x2b, 0, 0x28);
    sVar3 = strlen(string);
    memcpy(value + 0x2b, string, sVar3);
    memcpy(test_name + 0x2b, "tmbcShiftNo", 0x14);
    string[0xc] = '\0';
    value[0x2c].ldata = monitor.tmbcOperator;
    memcpy(test_name + 0x2c, "tmbcOperator", 0x14);
    value[0x2d].ldata = monitor.tmbcVINo;
    memcpy(test_name + 0x2d, "tmbcVINo", 0x14);
    tmbcCoolTime.dwValue._2_2_ = monitor.tmbcCoolTime_2;
    tmbcCoolTime.dwValue._0_2_ = monitor.tmbcCoolTime_1;
    value[0x2e].ldata = tmbcCoolTime;
    memcpy(test_name + 0x2e, "tmbcCoolTime", 0x14);
  }
  else
  {
    value[0x26].sdata = monitor.tmChargeMaxPressB;
    memcpy(test_name + 0x26, "tmChargeMaxPressB", 0x14);
  }
  value[0x2f]._0_1_ = monitor.other_data[0x16];
  value[0x2f]._1_1_ = monitor.other_data[0x17];
  value[0x2f]._2_1_ = monitor.other_data[0x18];
  value[0x2f]._3_1_ = monitor.other_data[0x19];
  memcpy(test_name + 0x2f, "tmPowerConsumptionPerModule", 0x1b);
  for (i = 0; i < 0x30; i = i + 1)
  {
    uVar4 = *(uint32_t *)((int)value + i * 0x28 + 8);
    in_stack_00000000 = in_stack_00000000;
    auVar6 = CONCAT284(in_stack_00000000, uVar4);
    uVar5 = *(uint64_t *)(value + i);
    value_00 = (DBVALUE)CONCAT328(auVar6, uVar5);
    compare_get_value(test_name[i], value_00);
  }
  return;
}

void EncryptString(char *input, char *output, uint16_t inputlen)

{
  int iVar1;
  uint16_t inputlen_local;
  char *output_local;
  char *input_local;
  int temp;
  int number;
  int i;
  int j;

  j = 0;
  if ((inputlen != 0) || (input != (char *)0x0))
  {
    for (i = 0; iVar1 = (inputlen / 10) * 10, iVar1 - i != 0 && i <= iVar1; i = i + 1)
    {
      if (i % 10 < 5)
      {
        output[(i / 10) * 10 + (4 - i % 10)] = input[i];
      }
      else
      {
        output[i] = input[i];
      }
    }
    for (i = (inputlen / 10) * 10; i < (int)(uint)inputlen; i = i + 1)
    {
      output[i] = input[i];
    }
    for (i = 0; i < (int)(uint)inputlen; i = i + 1)
    {
      j = j + 1;
      output[i] = output[i] + (char)j;
      if (j == 10)
      {
        j = 0;
      }
    }
  }
  return;
}

void DecryptString(char *input, char *output, uint16_t inputlen)

{
  int iVar1;  uint16_t inputlen_local;  char *output_local;  char *input_local;  char temp[32];  int number;  int tmp;  int i;  int j;

  j = 0;
  if ((inputlen != 0) || (input != (char *)0x0))
  {
    for (i = 0; i < (int)(uint)inputlen; i = i + 1)
    {
      j = j + 1;
      temp[i] = input[i] - (char)j;
      if (j == 10)
      {
        j = 0;
      }
    }
    for (i = 0; iVar1 = (inputlen / 10) * 10, iVar1 - i != 0 && i <= iVar1; i = i + 1)
    {
      if (i % 10 < 5)
      {
        output[i] = temp[i];
      }
      else
      {
        output[(i / 10) * 10 + (0xe - i % 10)] = temp[i];
      }
    }
    for (i = (inputlen / 10) * 10; i < (int)(uint)inputlen; i = i + 1)
    {
      output[i] = temp[i];
    }
  }
  return;
}

void encry(void *pData, char *msg_buff)

{
  char *msg_buff_local;  void *pData_local;  int buf_length;  uint32_t nCRC;  char sendbuf[60];  char msg_buff_new_1[33];  int wLength;  INTHEADER *pInetHeader;

  memset(sendbuf, 0, 0x3c);
  EncryptString(msg_buff, msg_buff_new_1, 0x20);
  msg_buff_new_1[0x20] = '\0';
  *(uint32_t *)((int)pData + 8) = 1;
  *(uint32_t *)((int)pData + 0xc) = 0x200000b;
  memcpy(sendbuf, pData, 0x10);
  sendbuf[0x10] = ' ';
  sendbuf[0x11] = '\0';
  memcpy(sendbuf + 0x12, msg_buff_new_1, 0x20);
  *(uint16_t *)((int)pData + 2) = 0x36;
  memcpy(sendbuf, pData, 0x10);
  sendbuf._50_4_ = GetCRC32(sendbuf, 0x32);
  sendto(sockfd, sendbuf, 0x36, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void Dealidentification_rsa(void *pData, WORD wLength)

{
  char *__s;
  size_t ptf_en_length_00;
  ushort uVar1;
  WORD wLength_local;
  void *pData_local;
  Signmes signmessage;
  char msg_buff[1024];
  WORD_T msg_length;
  INTHEADER *pInetHeader;
  int ptf_en_length;
  char *ptf_en;

  uVar1 = *(ushort *)((int)pData + 0x10);
  memcpy(msg_buff, (void *)((int)pData + 0x12), (uint)uVar1);
  __s = my_decrypt(msg_buff, "privkey_2049.pem", (uint)uVar1);
  ptf_en_length_00 = strlen(__s);
  test_RSA_sign(&signmessage, __s, ptf_en_length_00);
  *(uint32_t *)((int)pData + 8) = 1;
  *(uint32_t *)((int)pData + 0xc) = 0x200000b;
  *(uint16_t *)((int)pData + 0x10) = (uint16_t)signmessage.size;
  memcpy((void *)((int)pData + 0x12), &signmessage, signmessage.size);
  uVar1 = (short)signmessage.size + 0x12;
  testdw_id = GetCRC32(pData, (uint)uVar1);
  nCRC = testdw_id;
  *(ulong *)((int)pData + (uint)uVar1) = testdw_id;
  uVar1 = (short)signmessage.size + 0x16;
  *(ushort *)((int)pData + 2) = uVar1;
  sendto(sockfd, pData, (uint)uVar1, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

char *Dealidentification_self(void *pData, WORD wLength)

{
  ushort inputlen;
  WORD wLength_local;
  void *pData_local;
  char msg_buff[100];
  WORD_T msg_length;

  inputlen = *(ushort *)((int)pData + 0x10);
  memcpy(msg_buff, (void *)((int)pData + 0x12), (uint)inputlen);
  DecryptString(msg_buff, Dealidentification_self::decryptMsg, inputlen);
  Dealidentification_self::decryptMsg[inputlen] = '\0';
  return Dealidentification_self::decryptMsg;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void FindtmClpSPMode(void)

{
  int iVar1;
  int i;

  i = 0;
  while (true)
  {
    if (999 < i)
    {
      return;
    }
    iVar1 = strcmp("tmClpSPMode", *(char **)(&DAT_001594ec + i * 0x40));
    if (iVar1 == 0)
      break;
    i = i + 1;
  }
  g_u16Index = (uint16_t)i;
  memset(&DBdata + i * 0x20, 0, 0x28);
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void ChangeMode(void)

{
  if (g_u16Version < 0x828)
  {
    g_u8ModeFlag = '\0';
    (&DBdata)[(uint)g_u16Index * 0x20] = 2;
  }
  else if ((&DBdata)[(uint)g_u16Index * 0x20] == 1)
  {
    g_u8ModeFlag = '\x02';
    (&DBdata)[(uint)g_u16Index * 0x20] = 1;
  }
  else
  {
    g_u8ModeFlag = '\x01';
    (&DBdata)[(uint)g_u16Index * 0x20] = 0;
  }
  return;
}

// WARNING: Unknown calling convention -- yet parameter storage is locked

void SendBoundApplication(void)

{
  char byBoundData[18];
  int wlen;

  byBoundData[0] = '\x02';
  byBoundData[1] = '\0';
  byBoundData[2] = '\0';
  byBoundData[3] = '\0';
  byBoundData[4] = '\0';
  byBoundData[5] = '\0';
  byBoundData[6] = '\0';
  byBoundData[7] = '\0';
  byBoundData[8] = '\x01';
  byBoundData[9] = '\0';
  byBoundData[10] = '\0';
  byBoundData[0xb] = '\0';
  byBoundData[0xc] = '\x04';
  byBoundData[0xd] = '\0';
  byBoundData[0xe] = '\0';
  byBoundData[0xf] = 'B';
  byBoundData[0x10] = '\x01';
  byBoundData[0x11] = '\0';
  sendto(sockfd, byBoundData, 0x12, 0, (sockaddr *)&adr_clnt, 0x10);
  return;
}

void SendOPState(BYTE *byData)

{
  BYTE *byData_local;
  char *psz_end;
  char *psz_workstate;
  char *psz_colon;
  char *psz_workmode;
  char *psz_head;
  int nResult;

  memset(&operstate, 0, 0x58);
  if ((uint)u_recvbuff_length < 0x5f)
  {
    memcpy(&operstate, byData, 0x4c);
  }
  else
  {
    memcpy(&operstate, byData, 0x58);
  }
  memset(g_awNet2TxBuffer, 0, 0x2f5);
  g_awNet2TxBuffer[0] = '{';
  memcpy(g_awNet2TxBuffer + 1, "\"WorkMode\"", 10);
  g_awNet2TxBuffer[0xb] = ':';
  if (operstate.wOperState == 3)
  {
    memcpy(g_awNet2TxBuffer + 0xc, "\"ModeSemiAuto\"", 0xe);
    nResult = 0x1a;
  }
  else if (operstate.wOperState == 9)
  {
    memcpy(g_awNet2TxBuffer + 0xc, "\"ModeAuto\"", 10);
    nResult = 0x16;
  }
  else if (operstate.wOperState == 0)
  {
    memcpy(g_awNet2TxBuffer + 0xc, "\"ModeManu\"", 10);
    nResult = 0x16;
  }
  else
  {
    memcpy(g_awNet2TxBuffer + 0xc, "\"ModeManu\"", 10);
    nResult = 0x16;
  }
  g_awNet2TxBuffer[nResult] = '}';
  return;
}

void N2A(char *psz, WORD_T *pLen, DWORD dwValue, int nPrecision)

{
  uint uVar1;
  double dVar2;
  int nPrecision_local;
  DWORD dwValue_local;
  WORD_T *pLen_local;
  char *psz_local;
  DWORD dw_temp;
  DWORD u_dwCycleValue;
  int i_c;
  int i;
  int number;

  for (i_c = 9; 0 < i_c; i_c = i_c + -1)
  {
    dVar2 = pow(10.0, (double)(longlong)i_c);
    uVar1 = __aeabi_uidiv(dwValue, (uint)(0.0 < dVar2) * (int)(longlong)dVar2);
    if (uVar1 != 0)
      break;
  }
  for (i = 0; i <= i_c; i = i + 1)
  {
    dVar2 = pow(10.0, (double)(longlong)(i_c - i));
    if (i == i_c)
    {
      number = dwValue % 10;
    }
    else
    {
      number = __aeabi_uidiv(dwValue, (uint)(0.0 < dVar2) * (int)(longlong)dVar2);
    }
    psz[i + 1] = (char)number + (char)(number / 10) * -10 + '0';
  }
  if (nPrecision == 0)
  {
    psz[i_c + 2] = '\"';
    *pLen = (short)i_c + 3;
  }
  else if (i_c < nPrecision)
  {
    for (i = 0; i < i_c + 1; i = i + 1)
    {
      psz[(nPrecision + 2) - i] = psz[(i_c - i) + 1];
    }
    for (i = 0; i < (nPrecision - i_c) + -1; i = i + 1)
    {
      psz[i + 3] = '0';
    }
    psz[1] = '0';
    psz[2] = '.';
    psz[nPrecision + 3] = '\"';
    *pLen = (short)nPrecision + 4;
  }
  else
  {
    for (i = 0; i < nPrecision; i = i + 1)
    {
      psz[(i_c + 2) - i] = psz[(i_c - i) + 1];
    }
    psz[(i_c - nPrecision) + 2] = '.';
    psz[i_c + 3] = '\"';
    *pLen = (short)i_c + 4;
  }
  return;
}

void SendMonitor(BYTE *byData)

{
  int iVar1;
  BYTE *byData_local;
  char psz_MoldNoT[16];
  char psz_InjectValueT[32];
  char psz_CycleValueT[32];
  WORD_T wLength;
  char *psz_end;
  char *psz_DateTime;
  char *psz_TimeH;
  char *psz_MoldNoH;
  char *psz_InjectValueH;
  char *psz_comma;
  char *psz_colon;
  char *psz_CycleValueH;
  char *psz_head;
  int nResult;

  nResult = 0;
  wLength = 0;
  psz_head = "{";
  psz_CycleValueH = "\"CyclicTime\"";
  psz_colon = ":";
  memset(psz_CycleValueT, 0, 0x20);
  psz_CycleValueT[0] = '\"';
  psz_comma = ",";
  psz_InjectValueH = "\"InjectTime\"";
  memset(psz_InjectValueT, 0, 0x20);
  psz_InjectValueT[0] = '\"';
  psz_MoldNoH = "\"MoldNo.\"";
  psz_MoldNoT[4] = '\0';
  psz_MoldNoT[5] = '\0';
  psz_MoldNoT[6] = '\0';
  psz_MoldNoT[7] = '\0';
  psz_MoldNoT[8] = '\0';
  psz_MoldNoT[9] = '\0';
  psz_MoldNoT[10] = '\0';
  psz_MoldNoT[0xb] = '\0';
  psz_MoldNoT[0xc] = '\0';
  psz_MoldNoT[0xd] = '\0';
  psz_MoldNoT[0xe] = '\0';
  psz_MoldNoT[0xf] = '\0';
  psz_MoldNoT[0] = '\"';
  psz_MoldNoT[1] = '\0';
  psz_MoldNoT[2] = '\0';
  psz_MoldNoT[3] = '\0';
  psz_TimeH = "\"Time\"";
  psz_DateTime = "\"2017-11-19 17:57:34\"";
  psz_end = "}";
  memset(&monitor, 0, 0xe0);
  memcpy(&monitor, byData, 0xe0);
  memset(g_awNet2TxBuffer, 0, 0x2f5);
  g_awNet2TxBuffer[nResult] = *psz_head;
  iVar1 = nResult + 1;
  nResult = nResult + 1;
  memcpy(g_awNet2TxBuffer + iVar1, psz_CycleValueH, 0xc);
  g_awNet2TxBuffer[nResult + 0xc] = *psz_colon;
  nResult = nResult + 0xd;
  N2A(psz_CycleValueT, &wLength, monitor.dwCycletime, 2);
  memcpy(g_awNet2TxBuffer + nResult, psz_CycleValueT, (uint)wLength);
  iVar1 = nResult + (uint)wLength;
  g_awNet2TxBuffer[iVar1] = *psz_comma;
  nResult = iVar1 + 1;
  memcpy(g_awNet2TxBuffer + iVar1 + 1, psz_InjectValueH, 0xc);
  g_awNet2TxBuffer[nResult + 0xc] = *psz_colon;
  nResult = nResult + 0xd;
  N2A(psz_InjectValueT, &wLength, monitor.dwInjecttime, 2);
  memcpy(g_awNet2TxBuffer + nResult, psz_InjectValueT, (uint)wLength);
  iVar1 = nResult + (uint)wLength;
  g_awNet2TxBuffer[iVar1] = *psz_comma;
  nResult = iVar1 + 1;
  memcpy(g_awNet2TxBuffer + iVar1 + 1, psz_MoldNoH, 9);
  g_awNet2TxBuffer[nResult + 9] = *psz_colon;
  nResult = nResult + 10;
  N2A(psz_MoldNoT, &wLength, monitor.ulShotCount, 0);
  memcpy(g_awNet2TxBuffer + nResult, psz_MoldNoT, (uint)wLength);
  iVar1 = nResult + (uint)wLength;
  g_awNet2TxBuffer[iVar1] = *psz_comma;
  nResult = iVar1 + 1;
  memcpy(g_awNet2TxBuffer + iVar1 + 1, psz_TimeH, 6);
  g_awNet2TxBuffer[nResult + 6] = *psz_colon;
  iVar1 = nResult + 7;
  nResult = nResult + 7;
  memcpy(g_awNet2TxBuffer + iVar1, psz_DateTime, 0x15);
  g_awNet2TxBuffer[nResult + 0x15] = *psz_end;
  return;
}

void SendModify(BYTE *byData)

{
  BYTE *byData_local;  char psz_MoldNoT[16];  char psz_OldValueT[32];  char psz_NewValueT[32];  char psz_recordT[64];  char *psz_end;  char *psz_DateTime;  char *psz_TimeH;  char *psz_MoldNoH;  char *psz_OldValueH;  char *psz_NewValueH;  char *psz_comma;  char *psz_colon;  char *psz_recordH;  char *psz_head;  WORD_T wLength;  int nResult;

  memset(psz_recordT, 0, 0x40);
  psz_recordT[0] = '\"';
  psz_recordT[1] = '\"';
  memset(psz_NewValueT, 0, 0x20);
  psz_NewValueT[0] = '\"';
  memset(psz_OldValueT, 0, 0x20);
  psz_OldValueT[0] = '\"';
  memset(&modify, 0, 0x48);
  memcpy(&modify, byData, 0x48);
  return;
}

void GetAlarmUnicode(char *psz, WORD_T wErrorCode, WORD_T *pLen)

{
  WORD_T *pLen_local;
  WORD_T wErrorCode_local;
  char *psz_local;
  char psz_temp[64];
  WORD_T wErrorID;
  int i;

  memset(psz_temp, 0, 0x40);
  if (wErrorCode < 0x100)
  {
    for (i = 0; i < 0x20; i = i + 1)
    {
      if (Error[wErrorCode].g_DBErrorUnicode[i] == 0)
      {
        psz[i * 2 + 1] = '\"';
        *pLen = (WORD_T)((i + 1U & 0xffff) << 1);
        return;
      }
      psz[i * 2 + 1] = (char)(Error[wErrorCode].g_DBErrorUnicode[i] >> 8);
      psz[i * 2 + 2] = (char)Error[wErrorCode].g_DBErrorUnicode[i];
    }
  }
  return;
}

BOOL_T GetAlarmState(ERROR tagError)

{
  tagError.dateFixed.wYear = tagError.dateFixed.wYear;
  tagError.wErrorCode = (WORD_T)(tagError.dateFixed.wYear != 0);
  return tagError.wErrorCode;
}

void SendError(BYTE *byData)

{
  WORD_T WVar1;
  BOOL_T BVar2;
  WORD_T WVar4;
  WORD_T WVar5;
  BYTE BVar12;
  BYTE BVar14;
  WORD_T WVar15;
  BYTE BVar17;
  char cVar19;
  TIME TVar6;
  int iVar7;
  uint64_t uVar8;
  ERROR tagError;
  uint8_t auVar9[14];
  uint8_t auVar10[12];
  void6 uVar11;
  unkbyte10 in_stack_00000000;
  BYTE *byData_local;
  char psz_MoldNoT[16];
  char psz_alarmT[64];
  WORD_T wLength;
  char *psz_end;
  char *psz_DateTime;
  char *psz_TimeH;
  char *psz_MoldNoH;
  char *psz_comma;
  char *psz_colon;
  char *psz_alarmH;
  char *psz_head;
  DWORD_T dwShotCount;
  int nResult;
  uint32_t uVar3;
  uint16_t uVar13;
  uint32_t uVar16;
  uint16_t uVar18;

  nResult = 0;
  dwShotCount = 0;
  wLength = 0;
  psz_head = "{";
  psz_alarmH = "";
  psz_colon = ":";
  memset(psz_alarmT, 0, 0x40);
  psz_alarmT[0] = '\"';
  psz_alarmT[1] = '\"';
  psz_comma = ",";
  psz_MoldNoH = "\"MoldNo.\"";
  psz_MoldNoT[4] = '\0';
  psz_MoldNoT[5] = '\0';
  psz_MoldNoT[6] = '\0';
  psz_MoldNoT[7] = '\0';
  psz_MoldNoT[8] = '\0';
  psz_MoldNoT[9] = '\0';
  psz_MoldNoT[10] = '\0';
  psz_MoldNoT[0xb] = '\0';
  psz_MoldNoT[0xc] = '\0';
  psz_MoldNoT[0xd] = '\0';
  psz_MoldNoT[0xe] = '\0';
  psz_MoldNoT[0xf] = '\0';
  psz_MoldNoT[0] = '\"';
  psz_MoldNoT[1] = '\0';
  psz_MoldNoT[2] = '\0';
  psz_MoldNoT[3] = '\0';
  psz_TimeH = "\"Time\"";
  psz_DateTime = "\"2017-11-19 20:16:33\",";
  psz_end = "\"Encode\":\"Unicode\"}";
  memset(&error, 0, 0x1a);
  error._8_4_ = *(uint32_t *)(byData + 8);
  error.timeStart = *(TIME *)(byData + 0xc);
  error.wErrorCode = (WORD_T) * (uint32_t *)byData;
  error.wShotCount1 = (WORD_T)((uint) * (uint32_t *)byData >> 0x10);
  error.wShotCount2 = (WORD_T) * (uint32_t *)(byData + 4);
  error.dateStart._0_2_ = SUB42((uint) * (uint32_t *)(byData + 4) >> 0x10, 0);
  error.dateFixed._0_4_ = *(uint32_t *)(byData + 0x10);
  error.dateFixed.bWeek = byData[0x14];
  error.stay = byData[0x15];
  error.timeFixed.bHour = byData[0x16];
  error.timeFixed.bMinute = byData[0x17];
  error.timeFixed.bSecond = byData[0x18];
  error.timeFixed.bmSecond = byData[0x19];
  memset(g_awNet2TxBuffer, 0, 0x2f5);
  dwShotCount = CONCAT22(error.wShotCount2, error.wShotCount1);
  g_awNet2TxBuffer[nResult] = *psz_head;
  nResult = nResult + 1;
  WVar4 = error.wShotCount1;
  WVar1 = error.wErrorCode;
  uVar3 = CONCAT22(WVar4, WVar1);
  WVar5 = error.wShotCount2;
  uVar11 = CONCAT24(WVar5, uVar3);
  BVar12 = error.dateStart.bDay;
  register0x00000027 = error.dateStart.bMonth;
  uVar8 = CONCAT26(uVar13, uVar11);
  WVar15 = error.dateStart.wYear;
  register0x0000002a = error.dateStart.bWeek;
  register0x0000002b = error.unknow;
  auVar10 = CONCAT48(uVar16, uVar8);
  TVar6 = error.timeStart;
  auVar9 = CONCAT104(in_stack_00000000, TVar6);
  tagError = (ERROR)CONCAT1412(auVar9, auVar10);
  BVar2 = GetAlarmState(tagError);
  if (BVar2 == 0)
  {
    psz_alarmH = "\"Alarm\"";
    memcpy(g_awNet2TxBuffer + nResult, "\"Alarm\"", 7);
    nResult = nResult + 7;
  }
  else
  {
    psz_alarmH = "\"AlarmReset\"";
    memcpy(g_awNet2TxBuffer + nResult, "\"AlarmReset\"", 0xc);
    nResult = nResult + 0xc;
  }
  g_awNet2TxBuffer[nResult] = *psz_colon;
  nResult = nResult + 1;
  GetAlarmUnicode(psz_alarmT, error.wErrorCode, &wLength);
  memcpy(g_awNet2TxBuffer + nResult, psz_alarmT, (uint)wLength);
  iVar7 = nResult + (uint)wLength;
  g_awNet2TxBuffer[iVar7] = *psz_comma;
  nResult = iVar7 + 1;
  memcpy(g_awNet2TxBuffer + iVar7 + 1, psz_MoldNoH, 9);
  g_awNet2TxBuffer[nResult + 9] = *psz_colon;
  nResult = nResult + 10;
  N2A(psz_MoldNoT, &wLength, dwShotCount, 0);
  memcpy(g_awNet2TxBuffer + nResult, psz_MoldNoT, (uint)wLength);
  iVar7 = nResult + (uint)wLength;
  g_awNet2TxBuffer[iVar7] = *psz_comma;
  nResult = iVar7 + 1;
  memcpy(g_awNet2TxBuffer + iVar7 + 1, psz_TimeH, 6);
  g_awNet2TxBuffer[nResult + 6] = *psz_colon;
  iVar7 = nResult + 7;
  nResult = nResult + 7;
  memcpy(g_awNet2TxBuffer + iVar7, psz_DateTime, 0x16);
  iVar7 = nResult + 0x16;
  nResult = nResult + 0x16;
  memcpy(g_awNet2TxBuffer + iVar7, psz_end, 0x13);
  return;
}

void GetMoldSet(BYTE *byData)

{
  BYTE *__src;
  BYTE *byData_local;
  char packet_num;
  int packet_length;
  int length;

  __src = byData + 0x10;
  packet_num = (char)*(uint16_t *)(byData + 6);
  switch (packet_num)
  {
  case '\0':
    memset(&moldH, 0, 8);
    memcpy(&moldH, __src, 8);
    if (moldH.wSource != 0)
    {
      return;
    }
    memset(moldset_buff, 0, 6000);
    memcpy(moldset_buff, __src, u_recvbuff_length - 0x10);
    u_recv_length[0] = u_recvbuff_length + -0x10;
    break;
  case '\x01':
    u_recv_length[1] = u_recvbuff_length + -0x10;
    memcpy(moldset_buff + u_recv_length[0], __src, u_recvbuff_length - 0x10);
    break;
  case '\x02':
    u_recv_length[2] = u_recvbuff_length + -0x10;
    memcpy(moldset_buff + u_recv_length[0] + u_recv_length[1], __src, u_recvbuff_length - 0x10);
    break;
  case '\x03':
    u_recv_length[3] = u_recvbuff_length + -0x10;
    memcpy(moldset_buff + u_recv_length[0] + u_recv_length[1] + u_recv_length[2], __src,
           u_recvbuff_length - 0x10);
    break;
  case '\x04':
    u_recv_length[4] = u_recvbuff_length + -0x10;
    memcpy(moldset_buff + u_recv_length[0] + u_recv_length[1] + u_recv_length[2] + u_recv_length[3],
           __src, u_recvbuff_length - 0x10);
  }
  memcpy(moldset, moldset_buff + moldH.wMhdrLength + 8,
         (uint)moldH.wMoldSerALength + (uint)moldH.wMoldSerBLength);
  return;
}

ulong ParaseNetData_HMI(char *byData, int wLength)

{
  int wLength_local;
  char *byData_local;
  INTHEADER *pInetHeader;
  ulong dwProtocolID;

  return *(uint *)(byData + 0xc) & 0x3fffffff;
}

void GetTemper(BYTE *byData)

{
  BYTE *byData_local;

  if (byData != (BYTE *)0x0)
  {
    memcpy(&temper, byData, 0x54);
  }
  return;
}

void GetEnergy(BYTE *byData)

{
  BYTE *byData_local;

  if (byData != (BYTE *)0x0)
  {
    energy.tmTotalEnergyConsumption = *(DWORD_T *)byData;
  }
  return;
}

void GetXml(BYTE *byData)

{
  size_t sVar1;
  int iVar2;
  BYTE *byData_local;
  char mappingversion[10];
  int mappingversion_length;
  int setversion_length;
  int mainvrsion_length;
  ulong NEW_mappingversion;
  ulong HMI_mappingversion;
  int data_len;
  int length;

  // Unresolved local var: char * datetime@[???]
  // Unresolved local var: char * pEnd@[???]
  // Unresolved local var: long ldatetime@[???]
  if (byData != (BYTE *)0x0)
  {
    mappingversion[0] = '\0';
    mappingversion[1] = '\0';
    mappingversion[2] = '\0';
    mappingversion[3] = '\0';
    mappingversion[4] = '\0';
    mappingversion[5] = '\0';
    mappingversion[6] = '\0';
    mappingversion[7] = '\0';
    mappingversion[8] = '\0';
    mappingversion[9] = '\0';
    sVar1 = strlen((char *)byData);
    if (0x1e < (int)sVar1)
    {
      mainvrsion_length = CONCAT22(mainvrsion_length._2_2_, *(uint16_t *)(byData + 0x1e));
      if (mainvrsion_length + 0x20 < (int)sVar1)
      {
        setversion_length =
            CONCAT22(setversion_length._2_2_, *(uint16_t *)(byData + mainvrsion_length + 0x20));
        iVar2 = mainvrsion_length + 0x22 + setversion_length;
        if (iVar2 < (int)sVar1)
        {
          mappingversion._0_2_ = *(uint16_t *)(byData + iVar2 + 4);
          atoll(mappingversion);
        }
      }
    }
    if ((mappingversion[0] != '\0') && (iVar2 = access(black_file_name, 0), iVar2 == 0))
    {
      parseBlackList(black_file_name);
    }
  }
  return;
}
